//listPanelBase.tmpl

// The master template for the ListPanelBase classes

var panelName = t.GoName + "ListPanelBase"
var subPanelName = t.GoName + "ListPanel"

{{

package panel

// This file is generated by goradd. DO NOT EDIT. Your changes will be lost.

import(
	"context"
	html2 "github.com/goradd/goradd/pkg/html"
	"github.com/goradd/goradd/pkg/javascript"
	"github.com/goradd/goradd/pkg/orm/op"
	"github.com/goradd/goradd/pkg/orm/query"
	"github.com/goradd/goradd/pkg/page"
	"github.com/goradd/goradd/pkg/page/action"
	. "github.com/goradd/goradd/pkg/page/control"
	"github.com/goradd/goradd/pkg/page/control/column"
	"github.com/goradd/goradd/pkg/page/control/data"
	"github.com/goradd/goradd/pkg/page/event"
	"goradd-project/gen/{{= dd.DbKey }}/model"
	"goradd-project/gen/{{= dd.DbKey }}/model/node"
)

type {{= panelName }} struct {
	Panel
	List *PaginatedTable
	Paginator *DataPager
}

type {{= panelName }}I interface {
	PanelI
	CreateColumns()
	BuildQuery() *model.{{= t.GoPlural }}Builder
}


// this returns the interface for calling into "virtual" functions. This allows us to call functions defined
// by a subclass.
func (p *{{= panelName }}) this() {{= panelName }}I {
	return p.Self.({{= panelName }}I)
}

// CreateLister creates the object that lists the data
func (p *{{= panelName }}) CreateList(rowClickActionID int) {
	p.List = NewPaginatedTable(p, p.ID() + "-list")

	p.Paginator = NewDataPager(p.List, p.ID() + "-pager", p.List)
	p.List.AddDataPager(p.Paginator)
	p.List.SetCaption(p.Paginator)

	p.List.On(event.CellClick().ActionValue(javascript.JsCode(event.CellClickRowId)), action.Ajax(p.ID(), rowClickActionID))
	p.List.AddClass("clickable-rows") // styles row so it highlights and has a click cursor, and prevents drag selecting items in the row

	p.List.SetRowStyler(p)
	p.List.SetDataProvider(p)

	p.this().CreateColumns()
}

// GetClickedRowID returns the id of the row that was clicked, based on the action parameters
func (p *{{= panelName }}) GetClickedRowID(a page.ActionParams) string {
	return a.EventValueString()
}

// CreateColumns creates the columns to display in the list control
// Override in {{= subPanelName }} to change what columns appear
func (p *{{= panelName }}) CreateColumns() {
{{for _,col := range t.Columns }}
    p.List.AddColumn(column.NewNodeColumn( node.{{= t.GoName }}().{{= col.GoName }}() ))
{{for}}
}


// BindData determines what records will be displayed in the lister.
// Override to change what records get displayed.
func (p *{{= panelName }}) BindData(ctx context.Context, s data.DataManagerI) {
	if p.List.HasDataPagers() {
		p.List.SetTotalItems(p.this().BuildQuery().Count(ctx, false))
	}

	builder := p.this().BuildQuery()

	// Since we are asking the database to do the sort, we have to make a slice of nodes
	sortNodes := column.MakeNodeSlice(p.List.SortColumns())

	d := builder.Limit(p.List.SqlLimits()).
		OrderBy(sortNodes...).
		Load(ctx)

	s.SetData(d)
}

func (p *{{= panelName }}) BuildQuery() *model.{{= t.GoPlural }}Builder {
	return model.Query{{= t.GoPlural }}()
}

func (p *{{= panelName }}) MakeFilter(filterText string) query.NodeI {
	return op.Or(
{{for _,col := range t.Columns }}
		op.StartsWith(node.{{= t.GoName }}().{{= col.GoName }}(), filterText),
{{for}}
	)
}

func (p *{{= panelName }}) TableRowAttributes(row int, data interface{}) *html2.Attributes {
	return html2.NewAttributes().SetID(data.(*model.{{= t.GoName }}).PrimaryKey())
}

}}