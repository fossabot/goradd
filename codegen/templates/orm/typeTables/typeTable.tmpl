
propName := tt.GoName
propPlural := tt.GoPlural
propLetter := strings.ToLower(propName[0:1])
keyField := tt.FieldNames[0]

{{
package model

// Code generated by goradd. DO NOT EDIT.

import (
	//"log"
	//"github.com/goradd/goradd/pkg/orm/query"
	"strconv"
)

const (
}}
for _,value := range tt.Values {
	key,ok := value[keyField].(uint)
	if !ok {
		key = uint(value[keyField].(int))
	}
	con := tt.Constants[key]
{{
	{{= propName }}{{= con }} {{= propName }} = {{u key }}

}}
}

{{
)

const {{= propName }}MaxValue = {{i len(tt.Values) }}

type {{= propName }} uint

// String returns the name value of the type and satisfies the fmt.Stringer interface
func ({{= propLetter }} {{= propName }}) String() string {
	switch {{= propLetter }} {
	case 0: return ""
{{for _,value := range tt.Values }}
	case {{= generator.AsConstant(value[keyField], query.ColTypeUnsigned) }}: return {{= generator.AsConstant(value[tt.FieldNames[1]], query.ColTypeString) }}
{{for}}
	default: panic("Index out of range")
	}
	return "" // prevent warning
}

// ID returns a string representation of the id and satisfies the IDer interface
func ({{= propLetter }} {{= propName }}) ID() string {
	return strconv.Itoa(int({{= propLetter }}))
}

// {{= propPlural }} returns a slice of all the {{= propName }} items
func {{= propPlural }}() (values []{{= propName }}) {
{{for _,value := range tt.Values }}
    values = append(values, {{= generator.AsConstant(value[keyField], query.ColTypeUnsigned) }})
{{for}}
    return
}

// {{= propPlural }}I returns a slice of interfaces that contains all the {{= propName }} items
func {{= propPlural }}I() (values []interface{}) {
    values = make([]interface{}, {{i len(tt.Values) }}, {{i len(tt.Values) }})
{{for i,value := range tt.Values }}
    values[{{i i }}] = {{= propName }}({{= generator.AsConstant(value[keyField], query.ColTypeUnsigned) }})
{{for}}
    return
}


// Label returns the string that will be displayed to a user for this item. Together with
// the Value function, it satisfies the ItemLister interface that makes it easy
// to create a dropdown list of items.
func ({{= propLetter }} {{= propName }}) Label() string {
	return {{= propLetter }}.String()
}

// Value satisfies the Valuer interface.
func ({{= propLetter }} {{= propName }}) Value() interface{} {
	return {{= propLetter }}
}


}}

for i,fieldName := range tt.FieldNames[2:] {
	typ := tt.FieldGoColumnType(i+2)
	typeName := typ.GoType()
	title := db.UpperCaseIdentifier(fieldName)

{{
func ({{= propLetter }} {{= propName }}) {{= title }}() {{= typeName }} {
	switch {{= propLetter }} {
	case 0: return {{= typ.DefaultValue() }}
{{g for _,value := range tt.Values { }}
	case {{= generator.AsConstant(value[keyField], query.ColTypeUnsigned) }}: return {{= generator.AsConstant(value[tt.FieldNames[i+2]], typ) }}
{{g } }}
	default: panic("Index out of range")
	}
	return {{= typ.DefaultValue() }} // prevent warning
}
}}

}


for i,fieldName := range tt.FieldNames[1:] {
	typ := tt.FieldGoColumnType(i+1)
	typeName := typ.GoType()
	varName := inflector.Pluralize(fieldName)
	title := inflector.Pluralize(db.UpperCaseIdentifier(fieldName))

{{
func {{= propName }}{{= title }}() []{{= typeName }} {
	{{= varName }} := make([]{{= typeName }}, {{i len(tt.Values) + 1 }})
	// 0 item will be a blank
{{g for i,value := range tt.Values { }}
	{{= varName }}[{{i i + 1 }}] = {{= generator.AsConstant(value[fieldName], typ) }}
{{g } }}
	return {{= varName }}
}

}}

}
