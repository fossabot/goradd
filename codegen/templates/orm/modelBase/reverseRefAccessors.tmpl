//reverseRefAccessors.tmpl
for _,ref := range t.ReverseReferences {
	oName := ref.ObjName(dd)
	mName := ref.MapName()
	associatedGoName := ref.AssociatedGoName()

	if ref.IsUnique() {
{{

// {{ref.GoName}} returns the connected {{ref.GoType}} object, if one was loaded
// otherwise, it will return nil.
func (o *{{privateName}}Base) {{= ref.GoName }}() *{{ref.GoType}} {
	if o.{{oName}} == nil {
		return nil
	}
	return o.{{oName}}
}

// Load{{ref.GoName}} returns the connected {{ref.GoType}} object, if one was loaded
// otherwise, it will return nil.
func (o *{{privateName}}Base) Load{{= ref.GoName }}(ctx context.Context) *{{ref.GoType}} {
	if o.{{oName}} == nil {
		o.{{oName}} = Load{{ref.GoType}}By{{= associatedGoName }}(ctx, o.{{= t.PrimaryKeyColumn().GoName }}())
	}
	return o.{{oName}}
}


}}
	} else {

{{
// {{ref.GoName}} returns a single {{ref.GoType}} object by primary key, if one was loaded.
// Otherwise, it will return nil.
func (o *{{privateName}}Base) {{= ref.GoName }}(pk {{= ref.AssociatedPkType }}) *{{ref.GoType}} {
	if o.{{oName}} == nil || len(o.{{oName}}) == 0 {
		return nil
	}
	v,_ := o.{{mName}}[pk]
	return v
}

// {{ref.GoPlural}} returns a slice of {{ref.GoType}} objects if loaded.
func (o *{{privateName}}Base) {{= ref.GoPlural }}() []*{{ref.GoType}} {
	if o.{{oName}} == nil {
		return nil
	}
	return o.{{oName}}
}

// Load{{ref.GoPlural}} loads a new slice of {{ref.GoType}} objects and returns it.
func (o *{{privateName}}Base) Load{{= ref.GoPlural }}(ctx context.Context, conditions ...interface{}) []*{{ref.GoType}} {
	qb := query{{ref.GoTypePlural}}(ctx)
	cond := Equal(node.{{= ref.GoType }}().{{= associatedGoName }}(), o.PrimaryKey())
	if conditions != nil {
		conditions = append(conditions, cond)
	    cond = And(conditions...)
	}

	o.{{oName}} = qb.Where(cond).Load(ctx)
	return o.{{oName}}
}


{{if ref.IsNullable() }}

// DisassociateAll{{ref.GoPlural}} removes the association of all of these types of objects.
func (o *{{privateName}}Base) DisassociateAll{{= ref.GoPlural }}(ctx context.Context) {
	for _,obj := range o.Load{{= ref.GoPlural }}(ctx) {
	    obj.Set{{= ref.AssociatedColumn.GoName}}(nil)
	    obj.Save(ctx)
	}
}

// Associate{{ref.GoPlural}} associates the given objects with the {{privateName}}.
func (o *{{privateName}}Base) Associate{{= ref.GoPlural }}(ctx context.Context, objs []*{{= ref.GoType }}) {
    for _,obj := range objs {
	    obj.Set{{= ref.AssociatedColumn.GoName}}(o.PrimaryKey())
	    obj.Save(ctx)
    }
}

{{if}}



}}
	}

}
