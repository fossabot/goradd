//TODO: Make sure dirty related objects are saved first
// TODO: Make sure id field cannot be set or updated

{{

// Save will update or insert the object, depending on the state of the object.
// If it has any auto-generated ids, those will be updated.
func (o *{{privateName}}Base) Save(ctx context.Context)  {
	if o._restored {
        if !o.IsDirty() {
            return
        }
		o.Update(ctx)
	} else {
		o.Insert(ctx)
	}
}

// Update will update the values in the database, saving any changed values.
func (o *{{privateName}}Base) Update(ctx context.Context) {
	if !o._restored {
		panic ("Cannot update a record that was not originally read from the database.")
	}
	m := o.getModifiedFields()
	if len(m) == 0 {
		return
	}
	d := db.GetDatabase("{{t.DbKey}}")
	txid := d.Begin(ctx)
    defer d.Rollback(ctx, txid)
	d.Update(ctx, "{{t.DbName}}", m, "{{= t.PrimaryKeyColumn().DbName }}", fmt.Sprint(o.{{= t.PrimaryKeyColumn().ModelName }}))

{{for _,ref := range t.ReverseReferences }}
    if o.{{= ref.Values["objName"]}}IsDirty {
    {{if ref.IsNullable() }}
        {{if ref.IsUnique()}}
           obj := Query{{= ref.AssociatedTable.GoPlural }}(ctx).
                    Where(op.Equal(node.{{= ref.AssociatedTable.GoName}}().{{= ref.AssociatedColumn.GoName}}(), o.PrimaryKey())).
                    Get(ctx)
           if obj != nil  && obj.PrimaryKey() != o.{{= ref.Values["objName"] }}.PrimaryKey() {
               obj.Set{{= ref.AssociatedColumn.GoName}}(nil)
               obj.Save(ctx)
           }
           o.{{= ref.Values["objName"]}}.Set{{= ref.AssociatedColumn.GoName}}(o.PrimaryKey())
           o.{{= ref.Values["objName"]}}.Save(ctx)
        {{else}}
           objs := Query{{= ref.AssociatedTable.GoPlural }}(ctx).
                      Where(op.Equal(node.{{= ref.AssociatedTable.GoName}}().{{= ref.AssociatedColumn.GoName}}(), o.PrimaryKey())).
                      Load(ctx)
           // TODO:select only the required fields
           for _,obj := range objs {
              if _,ok := o.{{= ref.Values["mapName"] }}[obj.PrimaryKey()]; !ok {
                  // The old object is not in the group of new objects
                  obj.Set{{= ref.AssociatedColumn.GoName}}(nil)
                  obj.Save(ctx)
              }
           }
           for _,obj := range o.{{= ref.Values["objName"] }} {
              obj.Set{{= ref.AssociatedColumn.GoName}}(o.PrimaryKey())
              obj.Save(ctx)
           }

        {{if}}
    {{else}} {{# not nullable}}
         {{if ref.IsUnique()}}
                // Since the other side of the relationship cannot be null, the object to be detached must be deleted
                obj := Query{{= ref.AssociatedTable.GoPlural }}(ctx).
                          Where(op.Equal(node.{{= ref.AssociatedTable.GoName}}().{{= ref.AssociatedColumn.GoName}}(), o.PrimaryKey())).
                          Get(ctx)
                if obj != nil  && obj.PrimaryKey() != o.{{= ref.Values["objName"] }}.PrimaryKey() {
                    obj.Delete(ctx)
                }
                o.{{= ref.Values["objName"]}}.Set{{= ref.AssociatedColumn.GoName}}(o.PrimaryKey())
                o.{{= ref.Values["objName"]}}.Save(ctx)
         {{else}}
                // Since the other side of the relationship cannot be null, the objects to be detached must be deleted
                // We take care to only delete objects that are not being reattached
                objs := Query{{= ref.AssociatedTable.GoPlural }}(ctx).
                           Where(op.Equal(node.{{= ref.AssociatedTable.GoName}}().{{= ref.AssociatedColumn.GoName}}(), o.PrimaryKey())).
                           Load(ctx)
                // TODO: select only the required fields
                for _,obj := range objs {
                   if _,ok := o.{{= ref.Values["mapName"] }}[obj.PrimaryKey()]; !ok {
                       // The old object is not in the group of new objects
                       obj.Delete(ctx)
                   }
                }
                for _,obj := range o.{{= ref.Values["objName"] }} {
                   obj.Set{{= ref.AssociatedColumn.GoName}}(o.PrimaryKey())
                   obj.Save(ctx)
                }
         {{if}}
    {{if}}
    }
{{for}}
    d.Commit(ctx, txid)
	o.resetDirtyStatus()
    broadcast.Update(ctx, "{{t.DbKey}}", "{{t.DbName}}", fmt.Sprintf("%v", o.{{= t.PrimaryKeyColumn().ModelName }}), stringmap.SortedKeys(m)...)
}

// Insert forces the object to be inserted into the database. If the object was loaded from the database originally,
// this will create a duplicate in the database.
func (o *{{privateName}}Base) Insert(ctx context.Context) {
	m := o.getModifiedFields()
	if len(m) == 0 {
		return
	}
	d := db.GetDatabase("{{t.DbKey}}")
    txid := d.Begin(ctx)
    defer d.Rollback(ctx, txid)

{{if t.PrimaryKeyColumn().IsId }}
	id := d.Insert(ctx, "{{t.DbName}}", m)
	o.{{= t.PrimaryKeyColumn().ModelName }} = id
{{else}}
	d.Insert(ctx, "{{t.DbName}}", m)
	id := o.PrimaryKey()
	_ = id
{{if}}
{{for _,ref := range t.ReverseReferences }}
    if o.{{= ref.Values["objName"]}}IsDirty {
        {{# Nullable or not nullable, we do the same thing since there is no need to detach anything since this is new}}
        {{if ref.IsUnique()}}
            o.{{= ref.Values["objName"]}}.Set{{= ref.AssociatedColumn.GoName}}(id)
            o.{{= ref.Values["objName"]}}.Save(ctx)
        {{else}}
            for _,obj := range o.{{= ref.Values["objName"]}} {
                obj.Set{{= ref.AssociatedColumn.GoName}}(id)
                obj.Save(ctx)
                if o.{{= ref.Values["mapName"]}} == nil {
                    o.{{= ref.Values["mapName"]}} = make(map[{{= ref.AssociatedPkType() }}]*{{= ref.GoType }})
                }
                o.{{= ref.Values["mapName"]}}[obj.PrimaryKey()] = obj
            }
        {{if}}
    }
{{for}}
    d.Commit(ctx, txid)
	o.resetDirtyStatus()
	o._restored = true
	broadcast.Insert(ctx, "{{t.DbKey}}", "{{t.DbName}}", fmt.Sprint(o.{{= t.PrimaryKeyColumn().ModelName }}))
}

func (o *{{privateName}}Base) getModifiedFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
}}

for _,col := range t.Columns {
{{
	if o.{{= col.ModelName }}IsDirty {
{{if col.IsNullable}}
        if 	o.{{= col.ModelName }}IsNull {
            fields["{{= col.DbName }}"] = nil
        } else {
  		    fields["{{= col.DbName }}"] = {{if col.ColumnType == query.ColTypeDateTime }}o.{{= col.ModelName }}.GoTime(){{else}}o.{{= col.ModelName }}{{if}}
        }
{{else}}
		fields["{{= col.DbName }}"] = {{if col.ColumnType == query.ColTypeDateTime }}o.{{= col.ModelName }}.GoTime(){{else}}o.{{= col.ModelName }}{{if}}
{{if}}
	}

}}
}

{{
	return
}

}}

