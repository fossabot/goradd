//** This file was code generated by got. ***

package template

import (
	"bytes"
	"fmt"
	"goradd/config"
	"strings"

	"github.com/knq/snaker"
	"github.com/spekary/goradd/codegen/generator"
	"github.com/spekary/goradd/orm/db"
	"github.com/spekary/goradd/orm/query"
	"github.com/spekary/goradd/util"
)

func init() {
	t := ModelBaseTemplate{
		generator.Template{
			Overwrite: true,
			TargetDir: config.LocalDir + "/gen",
		},
	}
	generator.AddTableTemplate(&t)
}

type ModelBaseTemplate struct {
	generator.Template
}

func (n *ModelBaseTemplate) FileName(key string, t *db.TableDescription) string {
	return n.TargetDir + "/" + key + "/model/" + t.GoName + ".base.go"
}

func (n *ModelBaseTemplate) GenerateTable(codegen generator.Codegen, dd *db.DatabaseDescription, t *db.TableDescription, buf *bytes.Buffer) {
	var privateName = util.LcFirst(t.GoName)
	//modelBase.tmpl

	// The master template for the modelBase classes

	buf.WriteString(`package model

// This file is code generated. Do not edit.

import (
	"goradd/gen/`)

	buf.WriteString(fmt.Sprintf("%v", t.DbKey))

	buf.WriteString(`/model/node"
	"github.com/spekary/goradd/orm/db"
	"github.com/spekary/goradd/orm/query"
	"context"
	"fmt"
	. "github.com/spekary/goradd/orm/op"
	//"./node"
	"github.com/spekary/goradd/datetime"
	"github.com/spekary/goradd/util/types"
)

`)

	// struct.tmpl

	buf.WriteString(`// `)

	buf.WriteString(fmt.Sprintf("%v", privateName))

	buf.WriteString(`Base is a base structure to be embedded in a "subclass" and provides the ORM access to the database.
// Do not directly access the internal variables, but rather use the accessor functions, since this class maintains internal state
// related to the variables.

type `)

	buf.WriteString(fmt.Sprintf("%v", privateName))

	buf.WriteString(`Base struct {
`)

	for _, col := range t.Columns {

		if col.IsId {
			buf.WriteString(`	`)

			buf.WriteString(col.VarName)

			buf.WriteString(` string
`)
		} else {

			buf.WriteString(`	`)

			buf.WriteString(col.VarName)

			buf.WriteString(` `)

			buf.WriteString(col.GoType.String())

			buf.WriteString(`
`)
		}
		if col.IsNullable {
			buf.WriteString(`	`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsNull bool
`)
		}

		buf.WriteString(`	`)

		buf.WriteString(col.VarName)

		buf.WriteString(`IsValid bool
	`)

		buf.WriteString(col.VarName)

		buf.WriteString(`IsDirty bool
`)
		if col.IsReference() && !col.ForeignKey.IsType {
			oName := dd.AssociatedObjectPrefix + col.ForeignKey.GoName

			buf.WriteString(`	`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` *`)

			buf.WriteString(col.ForeignKey.GoType)

			buf.WriteString(`
`)
		}
		buf.WriteString(`
`)

	} // for

	if len(t.ReverseReferences) > 0 {

		buf.WriteString(`
// Reverse reference objects.
`)

	} // if

	for _, ref := range t.ReverseReferences {
		if ref.IsUnique {

			buf.WriteString(`	`)

			buf.WriteString(fmt.Sprintf("%v", dd.AssociatedObjectPrefix))

			buf.WriteString(ref.GoName)

			buf.WriteString(` *`)

			buf.WriteString(ref.GoType)

			buf.WriteString(`
`)

		} else {

			buf.WriteString(`	`)

			buf.WriteString(fmt.Sprintf("%v", dd.AssociatedObjectPrefix))

			buf.WriteString(ref.GoPlural)

			buf.WriteString(` []*`)

			buf.WriteString(ref.GoType)

			buf.WriteString(` // Objects in the order they were queried
	m`)

			buf.WriteString(ref.GoPlural)

			buf.WriteString(` map[string] *`)

			buf.WriteString(ref.GoType)

			buf.WriteString(`					  // Objects by PK
`)

		}
	}

	if len(t.ManyManyReferences) > 0 {

		buf.WriteString(`
// Many-Many reference objects.
`)

	} // if

	for _, ref := range t.ManyManyReferences {

		buf.WriteString(`	`)

		buf.WriteString(fmt.Sprintf("%v", dd.AssociatedObjectPrefix))

		buf.WriteString(fmt.Sprintf("%v", ref.GoPlural))

		buf.WriteString(` []`)
		if !ref.IsTypeAssociation {
			buf.WriteString(`*`)
		}

		buf.WriteString(fmt.Sprintf("%v", ref.AssociatedObjectName))

		buf.WriteString(`
`)
		if !ref.IsTypeAssociation {
			buf.WriteString(`	m`)

			buf.WriteString(ref.GoPlural)

			buf.WriteString(` map[string] *`)

			buf.WriteString(fmt.Sprintf("%v", ref.AssociatedObjectName))

			buf.WriteString(`					  // Objects by PK
`)
		}

	} // for

	buf.WriteString(`
	// Custom aliases, if specified
	_aliases map[string]interface{}

	// Indicates whether this is a new object, or one loaded from the database. Used by Save to know whether to Insert or Update
	_restored bool
`)

	buf.WriteString(`}

`)

	//const.tmpl

	buf.WriteString(`
const  (
`)

	for _, col := range t.Columns {
		v := col.DefaultValueAsConstant()
		if v == "" {
			continue // no way to represent this as a constant
		}

		buf.WriteString(`	`)

		buf.WriteString(col.DefaultConstantName(t))

		buf.WriteString(` = `)

		buf.WriteString(v)

		buf.WriteString(`
`)

	}

	buf.WriteString(`)

`)

	//init.tmpl

	buf.WriteString(`
// Create a new `)

	buf.WriteString(t.GoName)

	buf.WriteString(` object and initialize to default values.
func New`)

	buf.WriteString(t.GoName)

	buf.WriteString(`() *`)

	buf.WriteString(t.GoName)

	buf.WriteString(` {
	o := `)

	buf.WriteString(t.GoName)

	buf.WriteString(`{}
	o.Initialize()
	return &o
}


// Initialize or re-initialize a `)

	buf.WriteString(t.GoName)

	buf.WriteString(` database object to default values.
func (o *`)

	buf.WriteString(fmt.Sprintf("%v", privateName))

	buf.WriteString(`Base) Initialize() {

`)
	for _, col := range t.Columns {
		buf.WriteString(`	o.`)

		buf.WriteString(fmt.Sprintf("%v", col.VarName))

		buf.WriteString(` = `)

		buf.WriteString(col.DefaultValueAsValue())

		buf.WriteString(`
`)
		if col.IsNullable {
			if col.DefaultValue == nil {
				buf.WriteString(`	o.`)

				buf.WriteString(fmt.Sprintf("%v", col.VarName))

				buf.WriteString(`IsNull = true
	o.`)

				buf.WriteString(fmt.Sprintf("%v", col.VarName))

				buf.WriteString(`IsValid = true
	o.`)

				buf.WriteString(fmt.Sprintf("%v", col.VarName))

				buf.WriteString(`IsDirty = true
`)
			} else {

				buf.WriteString(`	o.`)

				buf.WriteString(fmt.Sprintf("%v", col.VarName))

				buf.WriteString(`IsNull = false
	o.`)

				buf.WriteString(fmt.Sprintf("%v", col.VarName))

				buf.WriteString(`IsValid = true
	o.`)

				buf.WriteString(fmt.Sprintf("%v", col.VarName))

				buf.WriteString(`IsDirty = true
`)
			}
		} else {
			if col.DefaultValue == nil {
				buf.WriteString(`	o.`)

				buf.WriteString(fmt.Sprintf("%v", col.VarName))

				buf.WriteString(`IsValid = false
	o.`)

				buf.WriteString(fmt.Sprintf("%v", col.VarName))

				buf.WriteString(`IsDirty = false
`)
			} else {

				buf.WriteString(`	o.`)

				buf.WriteString(fmt.Sprintf("%v", col.VarName))

				buf.WriteString(`IsValid = true
	o.`)

				buf.WriteString(fmt.Sprintf("%v", col.VarName))

				buf.WriteString(`IsDirty = true
`)
			}
		}

		buf.WriteString(`
`)
	}

	buf.WriteString(`

	o._restored = false
}


`)

	//pk.tmpl
	if t.PrimaryKeyColumn != nil {
		var typ string = t.PrimaryKeyColumn.GoType.String()

		buf.WriteString(`
func (o *`)

		buf.WriteString(fmt.Sprintf("%v", privateName))

		buf.WriteString(`Base) PrimaryKey() `)

		buf.WriteString(fmt.Sprintf("%v", typ))

		buf.WriteString(` {
	return o.`)

		buf.WriteString(t.PrimaryKeyColumn.VarName)

		buf.WriteString(`
}
`)

	}

	//accessors.tmpl

	// Getters
	for _, col := range t.Columns {
		if col.IsReference() && col.ForeignKey.IsType {
			continue
		}

		if col.IsId {

			buf.WriteString(`
// `)

			buf.WriteString(col.GoName)

			buf.WriteString(` returns the loaded value of `)

			buf.WriteString(col.GoName)

			buf.WriteString(`.
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) `)

			buf.WriteString(col.GoName)

			buf.WriteString(`() string {
	return fmt.Sprint(o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`)
}

// `)

			buf.WriteString(col.GoName)

			buf.WriteString(`IsValid returns true if the value was loaded from the database or has been set.
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) `)

			buf.WriteString(col.GoName)

			buf.WriteString(`IsValid() bool {
	return o._restored && o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsValid
}

`)

		} else {

			buf.WriteString(`
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) `)

			buf.WriteString(col.GoName)

			buf.WriteString(`() `)

			buf.WriteString(col.GoType.String())

			buf.WriteString(` {
	if o._restored && !o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsValid {
		panic ("`)

			buf.WriteString(col.VarName)

			buf.WriteString(` was not selected in the last query and so is not valid")
	}
	return o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`
}

// `)

			buf.WriteString(col.GoName)

			buf.WriteString(`IsValid returns true if the value was loaded from the database or has been set.
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) `)

			buf.WriteString(col.GoName)

			buf.WriteString(`IsValid() bool {
	return o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsValid
}

`)

		}

		if col.IsNullable {

			buf.WriteString(`
// `)

			buf.WriteString(col.GoName)

			buf.WriteString(`IsNull returns true if the related database value is null.
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) `)

			buf.WriteString(col.GoName)

			buf.WriteString(`IsNull() bool {
	return o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsNull
}

`)

		}

		if col.IsReference() {
			oName := dd.AssociatedObjectPrefix + col.ForeignKey.GoName

			buf.WriteString(`
// `)

			buf.WriteString(col.ForeignKey.GoName)

			buf.WriteString(` returns the current value of the loaded `)

			buf.WriteString(col.ForeignKey.GoName)

			buf.WriteString(`, and nil if its not loaded.
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) `)

			buf.WriteString(col.ForeignKey.GoName)

			buf.WriteString(`() *`)

			buf.WriteString(col.ForeignKey.GoType)

			buf.WriteString(` {
	return o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`
}

// Load`)

			buf.WriteString(col.ForeignKey.GoName)

			buf.WriteString(` returns the related `)

			buf.WriteString(col.ForeignKey.GoName)

			buf.WriteString(`. If it is not already loaded,
// it will attempt to load it first.
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) Load`)

			buf.WriteString(col.ForeignKey.GoName)

			buf.WriteString(`(ctx context.Context) *`)

			buf.WriteString(col.ForeignKey.GoType)

			buf.WriteString(` {
	if !o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsValid  {
		return nil
	}

	if o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` == nil {
		// Load and cache
		o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` = Load`)

			buf.WriteString(fmt.Sprintf("%v", col.ForeignKey.GoType))

			buf.WriteString(`(ctx, o.`)

			buf.WriteString(fmt.Sprintf("%v", col.GoName))

			buf.WriteString(`())
	}
	return o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`
}

`)

		}

		// Setters
		if col.IsId {
			continue // ID columns are not setable, since the database will automatically set the valid
		}

		// If the column is nullable, we use an interface to allow a null to be passed in
		if col.IsNullable {
			var oName string
			if col.IsReference() {
				oName = dd.AssociatedObjectPrefix + col.ForeignKey.GoName
			}

			buf.WriteString(`
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) Set`)

			buf.WriteString(col.GoName)

			buf.WriteString(`(i interface{}) {
	if i == nil {
		if !o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsNull {
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsNull = true
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsDirty = true
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(` = `)

			buf.WriteString(col.DefaultValueAsValue())

			buf.WriteString(`
`)
			if col.IsReference() && !col.ForeignKey.IsType {
				buf.WriteString(`			o.`)

				buf.WriteString(fmt.Sprintf("%v", oName))

				buf.WriteString(` = nil
`)
			}

			buf.WriteString(`		}
	} else {
		v := i.(`)

			buf.WriteString(col.GoType.String())

			buf.WriteString(`)
		if o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsNull ||
		    `)
			if col.GoType != query.COL_TYPE_BYTES {
				buf.WriteString(` o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(` != v `)
			} else {

				buf.WriteString(` !bytes.Equal(o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(`, v) `)
			}

			buf.WriteString(`{

			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsNull = false
`)
			if col.GoType != query.COL_TYPE_BYTES {
				buf.WriteString(`			o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(` = v
`)
			} else {

				buf.WriteString(`            o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(` = append([]byte(nil), v...)
`)
			}

			buf.WriteString(`			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsDirty = true
`)
			if col.IsReference() && !col.ForeignKey.IsType {
				buf.WriteString(`			o.`)

				buf.WriteString(fmt.Sprintf("%v", oName))

				buf.WriteString(` = nil
`)
			}

			buf.WriteString(`		}
	}
}

`)

			if col.IsReference() && !col.ForeignKey.IsType {
				oName := dd.AssociatedObjectPrefix + col.ForeignKey.GoName

				buf.WriteString(`
func (o *`)

				buf.WriteString(fmt.Sprintf("%v", privateName))

				buf.WriteString(`Base) Set`)

				buf.WriteString(col.ForeignKey.GoName)

				buf.WriteString(`(v *`)

				buf.WriteString(col.ForeignKey.GoType)

				buf.WriteString(`) {
	if v == nil {
		if !o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(`IsNull {
			o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(`IsNull = true
			o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(`IsDirty = true
			o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(`IsValid = true
			o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(` = `)

				buf.WriteString(col.DefaultValueAsValue())

				buf.WriteString(`
			o.`)

				buf.WriteString(fmt.Sprintf("%v", oName))

				buf.WriteString(` = nil
		}
	} else {
		o.`)

				buf.WriteString(fmt.Sprintf("%v", oName))

				buf.WriteString(`  = v
		if o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(`IsNull || o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(` != v.PrimaryKey() {
			o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(`IsNull = false
			o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(` = v.PrimaryKey()
			o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(`IsDirty = true
			o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(`IsValid = true
		}
	}
}

`)

			}

		} else { // Not nullable

			buf.WriteString(`// Set`)

			buf.WriteString(col.GoName)

			buf.WriteString(` sets the value of `)

			buf.WriteString(col.GoName)

			buf.WriteString(` in the object, to be saved later using the Save() function.
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) Set`)

			buf.WriteString(col.GoName)

			buf.WriteString(`(v `)

			buf.WriteString(col.GoType.String())

			buf.WriteString(`) {
`)
			if col.GoType == query.COL_TYPE_BYTES {
				buf.WriteString(`	o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(` = v		// TODO: Copy bytes??
	o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(`IsDirty = true
`)
			} else {
				buf.WriteString(`	if o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(` != v {
		o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(` = v
		o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(`IsDirty = true
`)
				if col.IsReference() && !col.ForeignKey.IsType {
					oName := dd.AssociatedObjectPrefix + col.ForeignKey.GoName

					buf.WriteString(`		o.`)

					buf.WriteString(fmt.Sprintf("%v", oName))

					buf.WriteString(` = nil
`)
				}
				buf.WriteString(`	}
`)
			}
			buf.WriteString(`

}

`)

			if col.IsReference() && !col.ForeignKey.IsType {
				oName := dd.AssociatedObjectPrefix + col.ForeignKey.GoName

				buf.WriteString(`// Set`)

				buf.WriteString(col.ForeignKey.GoName)

				buf.WriteString(` sets the value of `)

				buf.WriteString(col.ForeignKey.GoName)

				buf.WriteString(` in the object, to be saved later using the Save() function.
func (o *`)

				buf.WriteString(fmt.Sprintf("%v", privateName))

				buf.WriteString(`Base) Set`)

				buf.WriteString(col.ForeignKey.GoName)

				buf.WriteString(`(v *`)

				buf.WriteString(col.ForeignKey.GoType)

				buf.WriteString(`)  {
	if v == nil {
		panic("Cannot set `)

				buf.WriteString(col.ForeignKey.GoName)

				buf.WriteString(` to a null value.")
	} else {
		o.`)

				buf.WriteString(fmt.Sprintf("%v", oName))

				buf.WriteString(` = v
		if o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(` != v.PrimaryKey() {
			o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(` = v.PrimaryKey()
			o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(`IsDirty = true
			o.`)

				buf.WriteString(col.VarName)

				buf.WriteString(`IsValid = true
		}
	}
}

`)

			}

		} // else

	}

	buf.WriteString(`
// GetAlias returns the alias for the given key.
func (o *`)

	buf.WriteString(fmt.Sprintf("%v", privateName))

	buf.WriteString(`Base) GetAlias(key string) query.AliasValue {
	if a,ok := o._aliases[key]; ok {
		return query.NewAliasValue(a)
	} else {
		panic ("Alias " + key + " not found.")
		return query.NewAliasValue([]byte{})
	}
}
`)

	//typeAccessors.tmpl

	for _, col := range t.Columns {
		if !col.IsReference() || !col.ForeignKey.IsType {
			continue
		}

		suf := snaker.SnakeToCamel(dd.ForeignKeySuffix)
		goName := strings.TrimSuffix(col.GoName, suf)

		buf.WriteString(`

func (o *`)

		buf.WriteString(fmt.Sprintf("%v", privateName))

		buf.WriteString(`Base) `)

		buf.WriteString(goName)

		buf.WriteString(`() `)

		buf.WriteString(col.ForeignKey.GoType)

		buf.WriteString(` {
	if o._restored && !o.`)

		buf.WriteString(col.VarName)

		buf.WriteString(`IsValid {
		panic ("`)

		buf.WriteString(col.VarName)

		buf.WriteString(` was not selected in the last query and so is not valid")
	}
	return `)

		buf.WriteString(col.ForeignKey.GoType)

		buf.WriteString(`(o.`)

		buf.WriteString(col.VarName)

		buf.WriteString(`)
}

`)

		if col.IsNullable {

			buf.WriteString(`
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) `)

			buf.WriteString(goName)

			buf.WriteString(`IsNull() bool {
	return o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsNull
}

`)

		}

		// If the column is nullable, we use an interface to allow a null to be passed in
		if col.IsNullable {

			buf.WriteString(`
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) Set`)

			buf.WriteString(goName)

			buf.WriteString(`(i interface{}) {
	if i == nil {
		if !o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsNull {
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsNull = true
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsDirty = true
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsValid = true
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(` = `)

			buf.WriteString(col.DefaultValueAsValue())

			buf.WriteString(`
		}
	} else {
		v := i.(`)

			buf.WriteString(col.GoType.String())

			buf.WriteString(`)
		if o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsNull  {
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsNull = false
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(` = v
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsDirty = true
		}
	}
}

`)

		} else {

			buf.WriteString(`
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) Set`)

			buf.WriteString(goName)

			buf.WriteString(`(v `)

			buf.WriteString(col.ForeignKey.GoType)

			buf.WriteString(`) {
	if o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(` != `)

			buf.WriteString(fmt.Sprintf("%v", col.GoType.String()))

			buf.WriteString(`(v) {
		o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(` = `)

			buf.WriteString(fmt.Sprintf("%v", col.GoType.String()))

			buf.WriteString(`(v)
		o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsDirty = true
		o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsValid = true
	}
}

`)

		}

	} // for

	//manyManyAccessors.tmpl
	for _, ref := range t.ManyManyReferences {
		oName := dd.AssociatedObjectPrefix + ref.GoPlural
		if ref.IsTypeAssociation {

			buf.WriteString(`
// `)

			buf.WriteString(fmt.Sprintf("%v", ref.GoPlural))

			buf.WriteString(` returns a slice of `)

			buf.WriteString(fmt.Sprintf("%v", ref.AssociatedObjectName))

			buf.WriteString(` objects if loaded.
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) `)

			buf.WriteString(ref.GoPlural)

			buf.WriteString(`() []`)

			buf.WriteString(fmt.Sprintf("%v", ref.AssociatedObjectName))

			buf.WriteString(` {
	if o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` == nil {
		return nil
	}
	return o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`
}

// `)

			buf.WriteString(fmt.Sprintf("%v", ref.GoName))

			buf.WriteString(` returns a single `)

			buf.WriteString(fmt.Sprintf("%v", ref.AssociatedObjectName))

			buf.WriteString(` object, if one was loaded
// otherwise, it will return zero.
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) `)

			buf.WriteString(ref.GoName)

			buf.WriteString(`() `)

			buf.WriteString(fmt.Sprintf("%v", ref.AssociatedObjectName))

			buf.WriteString(` {
	if o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` == nil {
		return 0
	}
	return o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`[0]
}

`)

		} else {

			buf.WriteString(`// `)

			buf.WriteString(fmt.Sprintf("%v", ref.GoName))

			buf.WriteString(` returns a single `)

			buf.WriteString(fmt.Sprintf("%v", ref.AssociatedObjectName))

			buf.WriteString(` object, if one was loaded
// otherwise, it will return nil.
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) `)

			buf.WriteString(ref.GoName)

			buf.WriteString(`() *`)

			buf.WriteString(fmt.Sprintf("%v", ref.AssociatedObjectName))

			buf.WriteString(` {
	if o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` == nil {
		return nil
	}
	return o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`[0]
}

`)

			buf.WriteString(`
// `)

			buf.WriteString(fmt.Sprintf("%v", ref.GoPlural))

			buf.WriteString(` returns a slice of `)

			buf.WriteString(fmt.Sprintf("%v", ref.AssociatedObjectName))

			buf.WriteString(` objects if loaded. If not, will attempt to load
// the related objects and return what it finds.
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) `)

			buf.WriteString(ref.GoPlural)

			buf.WriteString(`() []*`)

			buf.WriteString(fmt.Sprintf("%v", ref.AssociatedObjectName))

			buf.WriteString(` {
	if o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` == nil {
		return nil
	}
	return o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`
}


`)

		}

	}

	//reverseRefAccessors.tmpl
	for _, ref := range t.ReverseReferences {
		var oName string
		var mName string

		if ref.IsUnique {
			oName = dd.AssociatedObjectPrefix + ref.GoName
		} else {
			oName = dd.AssociatedObjectPrefix + ref.GoPlural
			mName = "m" + ref.GoPlural
		}

		if ref.IsUnique {

			buf.WriteString(`
// `)

			buf.WriteString(fmt.Sprintf("%v", ref.GoName))

			buf.WriteString(` returns the connected `)

			buf.WriteString(fmt.Sprintf("%v", ref.GoType))

			buf.WriteString(` object, if one was loaded
// otherwise, it will return nil.
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) `)

			buf.WriteString(ref.GoName)

			buf.WriteString(`() *`)

			buf.WriteString(fmt.Sprintf("%v", ref.GoType))

			buf.WriteString(` {
	if o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` == nil {
		return nil
	}
	return o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`
}

`)

		} else {

			buf.WriteString(`// `)

			buf.WriteString(fmt.Sprintf("%v", ref.GoName))

			buf.WriteString(` returns a single `)

			buf.WriteString(fmt.Sprintf("%v", ref.GoType))

			buf.WriteString(` object by primary key, if one was loaded.
// Otherwise, it will return nil.
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) `)

			buf.WriteString(ref.GoName)

			buf.WriteString(`(pk string) *`)

			buf.WriteString(fmt.Sprintf("%v", ref.GoType))

			buf.WriteString(` {
	if o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` == nil || len(o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`) == 0 {
		return nil
	}
	v,_ := o.`)

			buf.WriteString(fmt.Sprintf("%v", mName))

			buf.WriteString(`[pk]
	return v
}

`)

			buf.WriteString(`
// `)

			buf.WriteString(fmt.Sprintf("%v", ref.GoPlural))

			buf.WriteString(` returns a slice of `)

			buf.WriteString(fmt.Sprintf("%v", ref.GoType))

			buf.WriteString(` objects if loaded.
func (o *`)

			buf.WriteString(fmt.Sprintf("%v", privateName))

			buf.WriteString(`Base) `)

			buf.WriteString(ref.GoPlural)

			buf.WriteString(`() []*`)

			buf.WriteString(fmt.Sprintf("%v", ref.GoType))

			buf.WriteString(` {
	if o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` == nil {
		return nil
	}
	return o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`
}


`)

		}

	}

	//query.tmpl
	// Top level query functions

	buf.WriteString(`
// Load`)

	buf.WriteString(fmt.Sprintf("%v", t.GoName))

	buf.WriteString(` queries for a single `)

	buf.WriteString(fmt.Sprintf("%v", t.GoName))

	buf.WriteString(` object by primary key.
// joinOrSelectNodes lets you provide nodes for joining to other tables or selecting specific fields. Table nodes will
// be considered Join nodes, and column nodes will be Select nodes. See Join() and Select() for more info.
// If you need a more elaborate query, use Query`)

	buf.WriteString(fmt.Sprintf("%v", t.GoPlural))

	buf.WriteString(`() to start a query builder.
func Load`)

	buf.WriteString(fmt.Sprintf("%v", t.GoName))

	buf.WriteString(`(ctx context.Context, pk string, joinOrSelectNodes ...query.NodeI) *`)

	buf.WriteString(fmt.Sprintf("%v", t.GoName))

	buf.WriteString(` {
	return Query`)

	buf.WriteString(fmt.Sprintf("%v", t.GoPlural))

	buf.WriteString(`().Where(Equal(node.`)

	buf.WriteString(fmt.Sprintf("%v", t.GoName))

	buf.WriteString(`().`)

	buf.WriteString(fmt.Sprintf("%v", t.PrimaryKeyColumn.GoName))

	buf.WriteString(`(), pk)).joinOrSelect(joinOrSelectNodes...).Get(ctx)
}

`)
	if t.Indexes != nil {
		for _, idx := range t.Indexes {
			if !idx.IsPrimary && idx.IsUnique {
				var names string

				for _, name := range idx.ColumnNames {
					names += snaker.SnakeToCamel(name)
				}

				buf.WriteString(`// Load`)

				buf.WriteString(fmt.Sprintf("%v", t.GoName))

				buf.WriteString(`By`)
				for _, name := range idx.ColumnNames {
					buf.WriteString(snaker.SnakeToCamel(name))
				}

				buf.WriteString(` queries for a single `)

				buf.WriteString(fmt.Sprintf("%v", t.GoName))

				buf.WriteString(` object by the given unique index values.
// joinOrSelectNodes lets you provide nodes for joining to other tables or selecting specific fields. Table nodes will
// be considered Join nodes, and column nodes will be Select nodes. See Join() and Select() for more info.
// If you need a more elaborate query, use Query`)

				buf.WriteString(fmt.Sprintf("%v", t.GoPlural))

				buf.WriteString(`() to start a query builder.
func Load`)

				buf.WriteString(fmt.Sprintf("%v", t.GoName))

				buf.WriteString(`By`)
				for _, name := range idx.ColumnNames {
					buf.WriteString(snaker.SnakeToCamel(name))
				}

				buf.WriteString(` (ctx context.Context`)
				for _, name := range idx.ColumnNames {
					buf.WriteString(`, `)

					buf.WriteString(name)

					buf.WriteString(` `)

					buf.WriteString(string(t.GetColumn(name).GoType))

					buf.WriteString(` `)
				}

				buf.WriteString(`, joinOrSelectNodes ...query.NodeI) *`)

				buf.WriteString(fmt.Sprintf("%v", t.GoName))

				buf.WriteString(` {
    return Query`)

				buf.WriteString(fmt.Sprintf("%v", t.GoPlural))

				buf.WriteString(`().
`)
				if len(idx.ColumnNames) == 1 {
					buf.WriteString(`        Where(Equal(node.`)

					buf.WriteString(fmt.Sprintf("%v", t.GoName))

					buf.WriteString(`().`)

					buf.WriteString(snaker.SnakeToCamel(idx.ColumnNames[0]))

					buf.WriteString(`(), `)

					buf.WriteString(idx.ColumnNames[0])

					buf.WriteString(`)).
`)
				} else {

					buf.WriteString(`        Where(And(`)
					for _, name := range idx.ColumnNames {
						buf.WriteString(`Equal(node.`)

						buf.WriteString(fmt.Sprintf("%v", t.GoName))

						buf.WriteString(`().`)

						buf.WriteString(snaker.SnakeToCamel(name))

						buf.WriteString(`(), `)

						buf.WriteString(name)

						buf.WriteString(`), `)
					}

					buf.WriteString(`)).
`)
				}

				buf.WriteString(`        joinOrSelect(joinOrSelectNodes...).
        Get(ctx)
}
`)

			}
		}
	}

	buf.WriteString(`


func Query`)

	buf.WriteString(fmt.Sprintf("%v", t.GoPlural))

	buf.WriteString(`() *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder {
	return new`)

	buf.WriteString(fmt.Sprintf("%v", t.GoName))

	buf.WriteString(`Builder()
}

// The `)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder is a private object using the QueryBuilderI interface from the database to build a query.
// All query operations go through this query builder.
// End a query by calling either Load, Count, or Delete
type `)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder struct {
	base query.QueryBuilderI
	hasConditionalJoins bool
}

func new`)

	buf.WriteString(fmt.Sprintf("%v", t.GoName))

	buf.WriteString(`Builder() *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder {
	b := &`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder{
		base: db.GetDatabase("`)

	buf.WriteString(fmt.Sprintf("%v", t.DbKey))

	buf.WriteString(`").
		NewBuilder(),
	}
	return b.Join(node.`)

	buf.WriteString(fmt.Sprintf("%v", t.GoName))

	buf.WriteString(`())
}

// Load terminates the query builder, performs the query, and returns a slice of `)

	buf.WriteString(fmt.Sprintf("%v", t.GoName))

	buf.WriteString(` objects. If there are
// any errors, they are returned in the context object. If no results come back from the query, it will return
// an empty slice
func (b *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder) Load(ctx context.Context) (`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Slice []*`)

	buf.WriteString(fmt.Sprintf("%v", t.GoName))

	buf.WriteString(`) {
	results := b.base.Load(ctx)
	if results == nil {
		return
	}
	for _,item := range results {
		o := New`)

	buf.WriteString(fmt.Sprintf("%v", t.GoName))

	buf.WriteString(`()
		o.load(item, !b.hasConditionalJoins, o, nil, "")
		`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Slice = append(`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Slice, o)
	}
	return `)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Slice
}

// LoadI terminates the query builder, performs the query, and returns a slice of interfaces. If there are
// any errors, they are returned in the context object. If no results come back from the query, it will return
// an empty slice.
func (b *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder) LoadI(ctx context.Context) (`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Slice []interface{}) {
	results := b.base.Load(ctx)
	if results == nil {
		return
	}
	for _,item := range results {
		o := New`)

	buf.WriteString(fmt.Sprintf("%v", t.GoName))

	buf.WriteString(`()
		o.load(item, !b.hasConditionalJoins, o, nil, "")
		`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Slice = append(`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Slice, o)
	}
	return `)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Slice
}


// Get is a convenience method to return only the first item found in a query. It is equivalent to adding
// Limit(1,0) to the query, and then getting the first item from the returned slice.
// Limits with joins do not currently work, so don't try it if you have a join
func (b *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder) Get(ctx context.Context) *`)

	buf.WriteString(fmt.Sprintf("%v", t.GoName))

	buf.WriteString(` {
	results := b.Limit(1,0).Load(ctx)
	if results != nil && len(results) > 0 {
		return results[0]
	} else {
		return nil
	}
}

// Expand expands an array type node so that it will produce individual rows instead of an array of items
func (b *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder) Expand(n query.NodeI) *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder {
	b.base.Expand(n)
	return b
}

// Join adds a node to the node tree so that its fields will appear in the query. Optionally add conditions to filter
// what gets included. The conditions will be AND'd with the basic condition matching the primary keys of the join.
func (b *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder) Join(n query.NodeI, conditions... query.NodeI) *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder {
	var condition query.NodeI
	if len(conditions) > 1 {
		condition = And(conditions)
	} else if len(conditions) == 1 {
		condition = conditions[0]
	}
	b.base.Join(n, condition)
	if condition != nil {
		b.hasConditionalJoins = true
	}
	return b
}

// Where adds a condition to filter what gets selected.
func (b *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder)  Where(c query.NodeI) *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder {
	b.base.Condition(c)
	return b
}

// OrderBy  spedifies how the resulting data should be sorted.
func (b *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder)  OrderBy(nodes... query.NodeI) *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder {
	b.base.OrderBy(nodes...)
	return b
}

// Limit willl return a subset of the data, limited to the offset and number of rows specified
func (b *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder)  Limit(maxRowCount int, offset int) *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder {
	b.base.Limit(maxRowCount, offset)
	return b
}

// Select optimizes the query to only return the specified fields. Once you put a Select in your query, you must
// specify all the fields that you will eventually read out. Be careful when selecting fields in joined tables, as joined
// tables will also contain pointers back to the parent table, and so the parent node should have the same field selected
// as the child node if you are querying those fields.
func (b *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder)  Select(nodes... query.NodeI) *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder {
	b.base.Select(nodes...)
	return b
}

// Alias lets you add a node with a custom name. After the query, you can read out the data using getAlias() on a
// returned object. Alias is useful for adding calculations or subqueries to the query.
func (b *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder)  Alias(name string, n query.NodeI) *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder {
	b.base.Alias(name, n)
	return b
}

// Distinct removes duplicates from the results of the query. Adding a Select() may help you get to the data you want, although
// using Distinct with joined tables is often not effective, since we force joined tables to include primary keys in the query, and this
// often ruins the effect of Distinct.
func (b *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder)  Distinct() *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder {
	b.base.Distinct()
	return b
}

// GroupBy controls how results are grouped when using aggregate functions in an Alias() call.
func (b *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder)  GroupBy(nodes... query.NodeI) *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder {
	b.base.GroupBy(nodes...)
	return b
}

func (b *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder)  Having(node query.NodeI)  *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder {
	 b.base.Having(node)
	 return b
}

// Count terminates a query and returns just the number of items selected.
func (b *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder)  Count(ctx context.Context, distinct bool, nodes... query.NodeI) uint {
	return b.base.Count(ctx, distinct, nodes...)
}

// Use the query builder to delete a group of records that match the criteria
func (b *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder)  Delete(ctx context.Context) {
	 b.base.Delete(ctx)
}

// Use the query builder to define a subquery within a larger query
func (b *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder)  Subquery() *query.SubqueryNode {
	 return b.base.Subquery()
}


// Private helper function for the Load* functions
func (b *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder) joinOrSelect(nodes ...query.NodeI) *`)

	buf.WriteString(fmt.Sprintf("%v", t.LcGoName))

	buf.WriteString(`Builder {
	for _,n := range nodes {
		switch n.(type) {
		case query.TableNodeI:
			b.base.Join(n, nil)
		case *query.ColumnNode:
			b.Select(n)
		}
	}
	return b
}


`)

	for _, col := range t.Columns {

		buf.WriteString(`
func Count`)

		buf.WriteString(fmt.Sprintf("%v", t.GoName))

		buf.WriteString(`By`)

		buf.WriteString(fmt.Sprintf("%v", col.GoName))

		buf.WriteString(`(ctx context.Context, `)

		buf.WriteString(fmt.Sprintf("%v", col.VarName))

		buf.WriteString(` `)

		buf.WriteString(fmt.Sprintf("%v", col.GoType))

		buf.WriteString(`) uint {
	return Query`)

		buf.WriteString(fmt.Sprintf("%v", t.GoPlural))

		buf.WriteString(`().Where(Equal(node.`)

		buf.WriteString(fmt.Sprintf("%v", t.GoName))

		buf.WriteString(`().`)

		buf.WriteString(fmt.Sprintf("%v", col.GoName))

		buf.WriteString(`(), `)

		buf.WriteString(fmt.Sprintf("%v", col.VarName))

		buf.WriteString(`)).Count(ctx, false)
}

`)

	}

	//loader.tmpl

	buf.WriteString(`// load is the private loader that transforms data coming from the database into a tree structure reflecting the relationships
// between the object chain requested by the user in the query.
// If linkParent is true we will have child relationships use a pointer back to the parent object. If false, it will create a separate object.
// Care must be taken in the query, as Select clauses might not be honored if the child object has fields selected which the parent object does not have.
// Also, if any joins are conditional, that might affect which child objects are included, so in this situation, linkParent should be false
func (o *`)

	buf.WriteString(fmt.Sprintf("%v", privateName))

	buf.WriteString(`Base) load (m map[string]interface{}, linkParent bool, objThis *`)

	buf.WriteString(fmt.Sprintf("%v", t.GoName))

	buf.WriteString(`, objParent interface{}, parentKey string) {
`)

	for _, col := range t.Columns {
		if col.IsNullable {

			buf.WriteString(`	if v, ok := m["`)

			buf.WriteString(col.DbName)

			buf.WriteString(`"]; ok {
		if v == nil {
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(` = `)

			buf.WriteString(col.DefaultValueAsValue())

			buf.WriteString(`
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsNull = true
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsValid = true
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsDirty = false
		} else if o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`, ok = v.(`)

			buf.WriteString(col.GoType.String())

			buf.WriteString(`); ok {
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsNull = false
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsValid = true
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsDirty = false
		} else {
			panic("Wrong type found for `)

			buf.WriteString(col.DbName)

			buf.WriteString(`.")
		}
	} else {
		o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsValid = false
		o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsNull = true
		o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(` = `)

			buf.WriteString(col.DefaultValueAsValue())

			buf.WriteString(`
	}
`)

		} else { // not IsNullable

			buf.WriteString(`	if v, ok := m["`)

			buf.WriteString(col.DbName)

			buf.WriteString(`"]; ok && v != nil {
		if o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`, ok = v.(`)

			buf.WriteString(col.GoType.String())

			buf.WriteString(`); ok {
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsValid = true
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsDirty = false
		} else {
			panic("Wrong type found for `)

			buf.WriteString(col.DbName)

			buf.WriteString(`.")
		}
	} else {
		o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsValid = false
		o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(` = `)

			buf.WriteString(col.DefaultValueAsValue())

			buf.WriteString(`
	}

`)

		} // else

		if col.IsReference() && !col.ForeignKey.IsType {
			oName := dd.AssociatedObjectPrefix + col.ForeignKey.GoName

			buf.WriteString(`	if linkParent && parentKey == "`)

			buf.WriteString(col.ForeignKey.GoName)

			buf.WriteString(`" {
		o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` = objParent.(*`)

			buf.WriteString(col.ForeignKey.GoType)

			buf.WriteString(`)
		o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsValid = true
		o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsDirty = false
	} else if v, ok := m["`)

			buf.WriteString(col.ForeignKey.GoName)

			buf.WriteString(`"]; ok {
		if `)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`, ok2 := v.(map[string]interface{}); ok2 {
			o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` = New`)

			buf.WriteString(col.ForeignKey.GoType)

			buf.WriteString(`()
			o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`.load(`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`, linkParent, o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`, objThis, "`)

			buf.WriteString(fmt.Sprintf("%v", col.ForeignKey.RR.GoPlural))

			buf.WriteString(`")
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsValid = true
			o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`IsDirty = false
		} else {
			panic("Wrong type found for `)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` object.")
		}
	} else {
		o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` = nil
	}

`)

		}

	}

	// Many-Many references
	for _, ref := range t.ManyManyReferences {
		oName := dd.AssociatedObjectPrefix + ref.GoPlural

		if ref.IsTypeAssociation {

			buf.WriteString(`	if v, ok := m["`)

			buf.WriteString(ref.GoPlural)

			buf.WriteString(`"]; ok {
		if `)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`, ok2 := v.([]uint); ok2 {
			o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` = []`)

			buf.WriteString(ref.AssociatedObjectName)

			buf.WriteString(`{}
			for _,m := range `)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` {
				o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` = append(o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`, `)

			buf.WriteString(ref.AssociatedObjectName)

			buf.WriteString(`(m))
			}
		} else {
			panic("Wrong type found for `)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` object.")
		}
	} else {
		o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` = nil
	}

`)

		} else {
			mName := "m" + ref.GoPlural
			pk := dd.TableDescription(ref.MM.AssociatedTableName).PrimaryKeyColumn.VarName

			buf.WriteString(`	if v, ok := m["`)

			buf.WriteString(ref.GoPlural)

			buf.WriteString(`"]; ok {
		if `)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`, ok2 := v.([]db.ValueMap); ok2 {
			o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` = []*`)

			buf.WriteString(ref.AssociatedObjectName)

			buf.WriteString(`{}
			o.`)

			buf.WriteString(fmt.Sprintf("%v", mName))

			buf.WriteString(` = map[string]*`)

			buf.WriteString(ref.AssociatedObjectName)

			buf.WriteString(`{}

			for _,v2 := range `)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` {
				obj := New`)

			buf.WriteString(ref.AssociatedObjectName)

			buf.WriteString(`()
				obj.load(v2, linkParent, obj, objThis, "`)

			buf.WriteString(fmt.Sprintf("%v", ref.MM.GoPlural))

			buf.WriteString(`")
				if linkParent && parentKey == "`)

			buf.WriteString(ref.GoPlural)

			buf.WriteString(`" && obj.`)

			buf.WriteString(fmt.Sprintf("%v", pk))

			buf.WriteString(` == objParent.(*`)

			buf.WriteString(ref.AssociatedObjectName)

			buf.WriteString(`).`)

			buf.WriteString(fmt.Sprintf("%v", pk))

			buf.WriteString(` {
					obj = objParent.(*`)

			buf.WriteString(ref.AssociatedObjectName)

			buf.WriteString(`)
				}
				o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` = append(o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`, obj)
				o.`)

			buf.WriteString(fmt.Sprintf("%v", mName))

			buf.WriteString(`[obj.`)

			buf.WriteString(fmt.Sprintf("%v", pk))

			buf.WriteString(`] = obj
			}
		} else {
			panic("Wrong type found for `)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` object.")
		}
	} else {
		o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` = nil
	}

`)

		}
	}

	// Reverse references
	for _, ref := range t.ReverseReferences {
		parentName := dd.TableDescription(ref.AssociatedTableName).GetColumn(ref.AssociatedColumnName).ForeignKey.GoName
		if ref.IsUnique {
			oName := dd.AssociatedObjectPrefix + ref.GoName

			buf.WriteString(`	if v, ok := m["`)

			buf.WriteString(ref.GoName)

			buf.WriteString(`"]; ok {
		if `)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`, ok2 := v.(db.ValueMap); ok2 {
			o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` = New`)

			buf.WriteString(ref.GoType)

			buf.WriteString(`()
			o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`.load(`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`, linkParent, o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`, objThis, "`)

			buf.WriteString(fmt.Sprintf("%v", parentName))

			buf.WriteString(`")
		} else {
			panic("Wrong type found for `)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` object.")
		}
	} else {
		o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` = nil
	}

`)

		} else {
			oName := dd.AssociatedObjectPrefix + ref.GoPlural
			mName := "m" + ref.GoPlural
			pk := dd.TableDescription(ref.AssociatedTableName).GetColumn(ref.AssociatedColumnName).VarName

			buf.WriteString(`	if v, ok := m["`)

			buf.WriteString(ref.GoPlural)

			buf.WriteString(`"]; ok {
		switch `)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` := v.(type) {
		case []db.ValueMap:
			o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` = []*`)

			buf.WriteString(ref.GoType)

			buf.WriteString(`{}
			o.`)

			buf.WriteString(fmt.Sprintf("%v", mName))

			buf.WriteString(` = map[string]*`)

			buf.WriteString(ref.GoType)

			buf.WriteString(`{}
			for _,v2 := range `)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` {
				obj := New`)

			buf.WriteString(ref.GoType)

			buf.WriteString(`()
				obj.load(v2, linkParent, obj, objThis, "`)

			buf.WriteString(fmt.Sprintf("%v", parentName))

			buf.WriteString(`")
				if linkParent && parentKey == "`)

			buf.WriteString(ref.GoPlural)

			buf.WriteString(`" && obj.`)

			buf.WriteString(fmt.Sprintf("%v", pk))

			buf.WriteString(` == objParent.(*`)

			buf.WriteString(ref.GoType)

			buf.WriteString(`).`)

			buf.WriteString(fmt.Sprintf("%v", pk))

			buf.WriteString(` {
					obj = objParent.(*`)

			buf.WriteString(ref.GoType)

			buf.WriteString(`)
				}
				o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` = append(o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`, obj)
				o.`)

			buf.WriteString(fmt.Sprintf("%v", mName))

			buf.WriteString(`[obj.`)

			buf.WriteString(fmt.Sprintf("%v", pk))

			buf.WriteString(`] = obj
			}
		case db.ValueMap:	// single expansion
			obj := New`)

			buf.WriteString(ref.GoType)

			buf.WriteString(`()
			obj.load(`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(`, linkParent, obj, objThis, "`)

			buf.WriteString(fmt.Sprintf("%v", parentName))

			buf.WriteString(`")
			if linkParent && parentKey == "`)

			buf.WriteString(ref.GoPlural)

			buf.WriteString(`" && obj.`)

			buf.WriteString(fmt.Sprintf("%v", pk))

			buf.WriteString(` == objParent.(*`)

			buf.WriteString(ref.GoType)

			buf.WriteString(`).`)

			buf.WriteString(fmt.Sprintf("%v", pk))

			buf.WriteString(` {
				obj = objParent.(*`)

			buf.WriteString(ref.GoType)

			buf.WriteString(`)
			}
			o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` = []*`)

			buf.WriteString(ref.GoType)

			buf.WriteString(`{obj}
		default:
			panic("Wrong type found for `)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` object.")
		}
	} else {
		o.`)

			buf.WriteString(fmt.Sprintf("%v", oName))

			buf.WriteString(` = nil
	}

`)

		}

	}

	buf.WriteString(`
	if v, ok := m["`)

	buf.WriteString(fmt.Sprintf("%v", query.AliasResults))

	buf.WriteString(`"]; ok {
		o._aliases = map[string]interface{}(v.(db.ValueMap))
	}
`)

	buf.WriteString(`	o._restored = true
}

`)

	//TODO: Make sure dirty related objects are saved first
	// TODO: Make sure id field cannot be set or updated

	buf.WriteString(`
// Save will update or insert the object, depending on the state of the object.
// If it has any auto-generated ids, those will be updated.
func (o *`)

	buf.WriteString(fmt.Sprintf("%v", privateName))

	buf.WriteString(`Base) Save(ctx context.Context)  {
	if o._restored {
		o.Update(ctx)
	} else {
		o.Insert(ctx)
	}
}

// Update will update the values in the database, saving any changed values.
func (o *`)

	buf.WriteString(fmt.Sprintf("%v", privateName))

	buf.WriteString(`Base) Update(ctx context.Context) {
	if !o._restored {
		panic ("Cannot update a record that was not originally read from the database.")
	}
	m := o.getModifiedFields()
	if len(m) == 0 {
		return
	}
	d := db.GetDatabase("`)

	buf.WriteString(fmt.Sprintf("%v", t.DbKey))

	buf.WriteString(`")
	d.Update(ctx, "`)

	buf.WriteString(fmt.Sprintf("%v", t.DbName))

	buf.WriteString(`", m, "`)

	buf.WriteString(t.PrimaryKeyColumn.DbName)

	buf.WriteString(`", fmt.Sprint(o.`)

	buf.WriteString(t.PrimaryKeyColumn.VarName)

	buf.WriteString(`))
	o.resetDirtyStatus()
}

// Insert forces the object to be inserted into the database. If the object was loaded from the database originally,
// this will create a duplicate in the database.
func (o *`)

	buf.WriteString(fmt.Sprintf("%v", privateName))

	buf.WriteString(`Base) Insert(ctx context.Context) {
	m := o.getModifiedFields()
	if len(m) == 0 {
		return
	}
	d := db.GetDatabase("`)

	buf.WriteString(fmt.Sprintf("%v", t.DbKey))

	buf.WriteString(`")
`)
	if t.PrimaryKeyColumn.IsId {
		buf.WriteString(`	id := d.Insert(ctx, "`)

		buf.WriteString(fmt.Sprintf("%v", t.DbName))

		buf.WriteString(`", m)
	o.`)

		buf.WriteString(t.PrimaryKeyColumn.VarName)

		buf.WriteString(` = id
`)
	} else {

		buf.WriteString(`	d.Insert(ctx, "`)

		buf.WriteString(fmt.Sprintf("%v", t.DbName))

		buf.WriteString(`", m)
`)
	}

	buf.WriteString(`	o.resetDirtyStatus()
	o._restored = true
}

func (o *`)

	buf.WriteString(fmt.Sprintf("%v", privateName))

	buf.WriteString(`Base) getModifiedFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
`)

	for _, col := range t.Columns {

		buf.WriteString(`	if o.`)

		buf.WriteString(col.VarName)

		buf.WriteString(`IsDirty {
		fields["`)

		buf.WriteString(col.DbName)

		buf.WriteString(`"] = `)
		if col.GoType == query.COL_TYPE_DATETIME {
			buf.WriteString(`o.`)

			buf.WriteString(col.VarName)

			buf.WriteString(`.GoTime()`)
		} else {

			buf.WriteString(`o.`)

			buf.WriteString(col.VarName)
		}

		buf.WriteString(`	}

`)

	}

	buf.WriteString(`	return
}

`)

	buf.WriteString(`func (o *`)

	buf.WriteString(fmt.Sprintf("%v", privateName))

	buf.WriteString(`Base) resetDirtyStatus() {
`)

	for _, col := range t.Columns {

		buf.WriteString(`	o.`)

		buf.WriteString(col.VarName)

		buf.WriteString(`IsDirty = false
`)

	}

	buf.WriteString(`}
`)

	buf.WriteString(`
// Delete deletes the associated record from the database.
func (o *`)

	buf.WriteString(fmt.Sprintf("%v", privateName))

	buf.WriteString(`Base) Delete(ctx context.Context) {
	if !o._restored {
		panic ("Cannot delete a record that has no primary key value.")
	}
	d := db.GetDatabase("`)

	buf.WriteString(fmt.Sprintf("%v", t.DbKey))

	buf.WriteString(`")
	d.Delete(ctx, "`)

	buf.WriteString(fmt.Sprintf("%v", t.DbName))

	buf.WriteString(`", "`)

	buf.WriteString(t.PrimaryKeyColumn.DbName)

	buf.WriteString(`", o.`)

	buf.WriteString(t.PrimaryKeyColumn.VarName)

	buf.WriteString(`)
}

// Delete`)

	buf.WriteString(t.GoName)

	buf.WriteString(` deletes the associated record from the database.
func Delete`)

	buf.WriteString(t.GoName)

	buf.WriteString(`(ctx context.Context, pk string) {
	d := db.GetDatabase("`)

	buf.WriteString(fmt.Sprintf("%v", t.DbKey))

	buf.WriteString(`")
	d.Delete(ctx, "`)

	buf.WriteString(fmt.Sprintf("%v", t.DbName))

	buf.WriteString(`", "`)

	buf.WriteString(t.PrimaryKeyColumn.DbName)

	buf.WriteString(`", pk)
}

`)

	//get.tmpl
	// Get Implements the Get function to return a field based on a field name
	// Returns an interface for further processing

	buf.WriteString(`
// Get returns the value of a field in the object based on the field's name.
// It will also get related objects if they are loaded.
// Invalid fields and objects are returned as nil
func (o *`)

	buf.WriteString(fmt.Sprintf("%v", privateName))

	buf.WriteString(`Base) Get(key string) interface{} {

    switch key {
`)

	for _, col := range t.Columns {
		var goName string

		if col.IsReference() {
			if col.ForeignKey.IsType {
				goName = col.GoName
			} else {
				goName = col.GoName
			}
		} else {
			goName = col.GoName
		}

		buf.WriteString(`    case "`)

		buf.WriteString(goName)

		buf.WriteString(`":
        if !o.`)

		buf.WriteString(col.VarName)

		buf.WriteString(`IsValid {
            return nil
        }
        return o.`)

		buf.WriteString(col.VarName)

		buf.WriteString(`
`)

		if col.IsReference() {

			buf.WriteString(`    case "`)

			buf.WriteString(col.ForeignKey.GoName)

			buf.WriteString(`":
        return o.`)

			buf.WriteString(col.ForeignKey.GoName)

			buf.WriteString(`()
`)

		} //if

	} // for

	for _, ref := range t.ReverseReferences {

		if ref.IsUnique {

			buf.WriteString(`    case "`)

			buf.WriteString(ref.GoName)

			buf.WriteString(`":
        return o.`)

			buf.WriteString(ref.GoName)

			buf.WriteString(`()
`)

		} else {

			buf.WriteString(`    case "`)

			buf.WriteString(ref.GoPlural)

			buf.WriteString(`":
        return o.`)

			buf.WriteString(ref.GoPlural)

			buf.WriteString(`()
`)

		} //else
	} // for

	for _, ref := range t.ManyManyReferences {

		buf.WriteString(`    case "`)

		buf.WriteString(ref.GoName)

		buf.WriteString(`":
        return o.`)

		buf.WriteString(ref.GoName)

		buf.WriteString(`()
    case "`)

		buf.WriteString(ref.GoPlural)

		buf.WriteString(`":
        return o.`)

		buf.WriteString(ref.GoPlural)

		buf.WriteString(`()
`)

	}

	buf.WriteString(`    }
    return nil
}
`)

}

func (n *ModelBaseTemplate) Overwrite() bool {
	return n.Template.Overwrite
}
