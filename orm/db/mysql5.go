//** This file is code generated by gopp. Do not edit.

package db

import (
	sqldb "database/sql"
	"fmt"
	"github.com/go-sql-driver/mysql"
	"strings"
	//"goradd/orm/query"
	"github.com/knq/snaker"
	//"github.com/spekary/goradd/util"
	"context"
	"strconv"
)

// goradd additions to the mysql database driver
// call NewMysql5, but afterwards, work through the DB parent interface

type Mysql5I interface {
	SqlDbI

	Describe() *DatabaseDescription
	generateColumnListWithAliases(b *sqlBuilder) (sql string, args []interface{})
	generateFromSql(b *sqlBuilder) (sql string, args []interface{})
	generateJoinSql(b *sqlBuilder, n NodeI) (sql string, args []interface{})
	generateNodeSql(n NodeI, useAlias bool) (sql string, args []interface{})
	generateSubquerySql(node *SubqueryNode) (sql string, args []interface{})
	generateOperationSql(n *OperationNode, useAlias bool) (sql string, args []interface{})
	generateColumnNodeSql(n *ColumnNode, useAlias bool) (sql string)
	generateNodeListSql(nodes []NodeI, useAlias bool) (sql string, args []interface{})
	generateOrderBySql(b *sqlBuilder) (sql string, args []interface{})
	generateGroupBySql(b *sqlBuilder) (sql string, args []interface{})
	generateWhereSql(b *sqlBuilder) (sql string, args []interface{})
	generateHaving(b *sqlBuilder) (sql string, args []interface{})
	generateLimitSql(b *sqlBuilder) (sql string)
	Update(ctx context.Context, table string, fields map[string]interface{}, pkName string, pkValue string)
	Insert(ctx context.Context, table string, fields map[string]interface{}) string
	Delete(ctx context.Context, table string, pkName string, pkValue interface{})
	makeSetSql(fields map[string]interface{}) (sql string, args []interface{})
}

type Mysql5 struct {
	SqlDb
	description *DatabaseDescription
	config      *mysql.Config
}

// New Mysql5 creates a new Mysql5 object and returns its matching interface
func NewMysql5(dbKey string, params string, config *mysql.Config) Mysql5I {
	m_ := Mysql5{}
	m_.Init(&m_)
	m_.Construct(dbKey, params, config)
	return m_.I().(Mysql5I)
}

func (m_ *Mysql5) Construct(dbKey string, params string, config *mysql.Config) {
	var err error

	m_.SqlDb.Construct(dbKey)

	if params == "" && config == nil {
		panic("Must specify how to connect to the database.")
	}
	if params == "" {
		params = config.FormatDSN()
		m_.config = config
	} else {
		m_.config, err = mysql.ParseDSN(params)
		if err != nil {
			panic("Could not parse the connection string.")
		}
	}
	m_.db, err = sqldb.Open("mysql", params)
	if err != nil {
		panic("Could not open database: " + err.Error())
	}
	err = m_.db.Ping()
	if err != nil {
		panic("Could not ping database: " + err.Error())
	}
	m_.loadDescription()
}

func (m_ *Mysql5) EscapeIdentifierBegin() string {
	return "`"
}

func (m_ *Mysql5) EscapeIdentifierEnd() string {
	return "`"
}

func (m_ *Mysql5) OnlyFullGroupBy() bool {
	return true
}

func (m_ *Mysql5) EscapeString(s string) string {
	return fmt.Sprintf("'%#v'", s)
}

func (m_ *Mysql5) Describe() *DatabaseDescription {
	return m_.description
}

func (m_ *Mysql5) generateSelectSql(b *sqlBuilder) (sql string, args []interface{}) {
	var s string
	var a []interface{}

	if b.distinct {
		sql = "SELECT DISTINCT\n"
	} else {
		sql = "SELECT\n"
	}

	s, a = m_.I().(Mysql5I).generateColumnListWithAliases(b)
	sql += s
	args = append(args, a...)

	s, a = m_.I().(Mysql5I).generateFromSql(b)
	sql += s
	args = append(args, a...)

	s, a = m_.I().(Mysql5I).generateWhereSql(b)
	sql += s
	args = append(args, a...)

	s, a = m_.I().(Mysql5I).generateGroupBySql(b)
	sql += s
	args = append(args, a...)

	s, a = m_.I().(Mysql5I).generateHaving(b)
	sql += s
	args = append(args, a...)

	s, a = m_.I().(Mysql5I).generateOrderBySql(b)
	sql += s
	args = append(args, a...)

	sql += m_.I().(Mysql5I).generateLimitSql(b)

	return
}

func (m_ *Mysql5) generateDeleteSql(b *sqlBuilder) (sql string, args []interface{}) {
	var s string
	var a []interface{}

	n := b.rootNode

	sql = "DELETE " + n.GetAlias() + " "

	s, a = m_.I().(Mysql5I).generateFromSql(b)
	sql += s
	args = append(args, a...)

	s, a = m_.I().(Mysql5I).generateWhereSql(b)
	sql += s
	args = append(args, a...)

	s, a = m_.I().(Mysql5I).generateOrderBySql(b)
	sql += s
	args = append(args, a...)

	sql += m_.I().(Mysql5I).generateLimitSql(b)

	return
}

func (m_ *Mysql5) generateColumnListWithAliases(b *sqlBuilder) (sql string, args []interface{}) {
	b.columnAliases.Range(func(key string, v interface{}) bool {
		node := v.(*ColumnNode)
		sql += m_.I().(Mysql5I).generateColumnNodeSql(node, false) + " AS `" + node.GetAlias() + "`,\n"
		return true
	})

	b.aliasNodes.Range(func(key string, v interface{}) bool {
		node := v.(NodeI)
		s, a := m_.I().(Mysql5I).generateNodeSql(node, false)
		sql += s + " AS `" + node.GetAlias() + "`,\n"
		args = append(args, a...)
		return true
	})

	sql = strings.TrimSuffix(sql, ",\n")
	sql += "\n"
	return
}

func (m_ *Mysql5) generateFromSql(b *sqlBuilder) (sql string, args []interface{}) {
	var s string
	var a []interface{}

	sql = "FROM\n"

	n := b.rootNode
	sql += "`" + n.tableName() + "` AS `" + n.GetAlias() + "`\n"

	var childNodes []NodeI
	var cn NodeI
	if childNodes = n.getChildNodes(); childNodes != nil {
		for _, cn = range childNodes {
			s, a = m_.I().(Mysql5I).generateJoinSql(b, cn)
			sql += s
			args = append(args, a...)
		}
	}
	return
}

func (m_ *Mysql5) generateJoinSql(b *sqlBuilder, n NodeI) (sql string, args []interface{}) {
	var tn TableNodeI
	var ok bool

	if tn, ok = n.(TableNodeI); !ok {
		return
	}

	switch node := tn.EmbeddedNode_().(type) {
	case *ReferenceNode:
		sql = "LEFT JOIN "
		sql += "`" + node.refTable + "` AS `" + node.GetAlias() + "` ON `" + node.getParentNode().GetAlias() + "`.`" + node.dbColumn + "` = `" + node.GetAlias() + "`.`" + node.refColumn + "`"
		if condition := node.getCondition(); condition != nil {
			s, a := m_.I().(Mysql5I).generateNodeSql(condition, false)
			sql += " AND " + s
			args = append(args, a...)
		}
	case *ReverseReferenceNode:
		if b.limitInfo != nil {
			panic("We do not currently support limited queries with an array join.")
		}

		sql = "LEFT JOIN "
		sql += "`" + node.refTable + "` AS `" + node.GetAlias() + "` ON `" + node.getParentNode().GetAlias() + "`.`" + node.dbColumn + "` = `" + node.GetAlias() + "`.`" + node.refColumn + "`"
		if condition := node.getCondition(); condition != nil {
			s, a := m_.I().(Mysql5I).generateNodeSql(condition, false)
			sql += " AND " + s
			args = append(args, a...)
		}
	case *ManyManyNode:
		if b.limitInfo != nil {
			panic("We do not currently support limited queries with an array join.")
		}

		sql = "LEFT JOIN "

		var pk string
		if node.isTypeTable {
			pk = snaker.CamelToSnake(m_.I().(Mysql5I).Describe().TypeTableDescription(node.refTable).PkField)
		} else {
			pk = m_.I().(Mysql5I).Describe().TableDescription(node.refTable).PrimaryKeyColumn.DbName
		}

		sql += "`" + node.dbTable + "` AS `" + node.GetAlias() + "a` ON `" + node.getParentNode().GetAlias() + "`.`" + node.getParentNode().(TableNodeI).PrimaryKeyNode_().name() +
			"` = `" + node.GetAlias() + "a`.`" + node.dbColumn + "`\n"
		sql += "LEFT JOIN `" + node.refTable + "` AS `" + node.GetAlias() + "` ON `" + node.GetAlias() + "a`.`" + node.refColumn +
			"` = `" + node.GetAlias() + "`.`" + pk + "`"

		if condition := node.getCondition(); condition != nil {
			s, a := m_.I().(Mysql5I).generateNodeSql(condition, false)
			sql += " AND " + s
			args = append(args, a...)
		}
	default:
		return
	}
	sql += "\n"
	if childNodes := n.getChildNodes(); childNodes != nil {
		for _, cn := range childNodes {
			s, a := m_.I().(Mysql5I).generateJoinSql(b, cn)
			sql += s
			args = append(args, a...)

		}
	}
	return
}

func (m_ *Mysql5) generateNodeSql(n NodeI, useAlias bool) (sql string, args []interface{}) {
	switch node := n.(type) {
	case *ValueNode:
		sql = "?"
		args = append(args, node.value)
	case *OperationNode:
		sql, args = m_.I().(Mysql5I).generateOperationSql(node, useAlias)
	case *ColumnNode:
		sql = m_.I().(Mysql5I).generateColumnNodeSql(node, useAlias)
	case *aliasNode:
		sql = "`" + node.GetAlias() + "`"
	case *SubqueryNode:
		sql, args = m_.I().(Mysql5I).generateSubquerySql(node)
	default:
		if tn, ok := n.(TableNodeI); ok {
			sql = m_.I().(Mysql5I).generateColumnNodeSql(tn.PrimaryKeyNode_(), false)
		} else {
			panic("Can't generate sql from m_.I().(Mysql5I) node type.")
		}

	}
	return
}

func (m_ *Mysql5) generateSubquerySql(node *SubqueryNode) (sql string, args []interface{}) {
	return
}

func (m_ *Mysql5) generateOperationSql(n *OperationNode, useAlias bool) (sql string, args []interface{}) {
	if useAlias && n.GetAlias() != "" {
		sql = n.GetAlias()
		return
	}
	switch n.op {
	case OpFunc:
		if len(n.operands) > 0 {
			for _, o := range n.operands {
				s, a := m_.I().(Mysql5I).generateNodeSql(o, useAlias)
				sql += s + ","
				args = append(args, a...)
			}
			sql = sql[:len(sql)-1]
		} else {
			if n.functionName == "COUNT" {
				sql = "*"
			}
		}

		if n.distinct {
			sql = "DISTINCT " + sql
		}
		sql = n.functionName + "(" + sql + ") "

	case OpNull:
		fallthrough
	case OpNotNull:
		s, a := m_.I().(Mysql5I).generateNodeSql(n.operands[0], useAlias)
		sql = s + " IS " + n.op.String()
		args = append(args, a...)
		sql = "(" + sql + ") "

	case OpNot:
		s, a := m_.I().(Mysql5I).generateNodeSql(n.operands[0], useAlias)
		sql = n.op.String() + " " + s
		args = append(args, a...)
		sql = "(" + sql + ") "

	case OpIn:
		fallthrough
	case OpNotIn:
		s, a := m_.I().(Mysql5I).generateNodeSql(n.operands[0], useAlias)
		sql = s + " " + n.op.String() + " ("
		args = append(args, a...)

		for _, o := range n.operands[1].(*ValueNode).value.([]NodeI) {
			s, a = m_.I().(Mysql5I).generateNodeSql(o, useAlias)
			sql += s + ","
			args = append(args, a...)
		}
		sql = strings.TrimSuffix(sql, ",") + ") "

	default:
		for _, o := range n.operands {
			s, a := m_.I().(Mysql5I).generateNodeSql(o, useAlias)
			sql += s + " " + n.op.String() + " "
			args = append(args, a...)
		}
		sql = strings.TrimSuffix(sql, " "+n.op.String()+" ")
		sql = "(" + sql + ") "

	}
	return
}

func (m_ *Mysql5) generateColumnNodeSql(n *ColumnNode, useAlias bool) (sql string) {
	if useAlias {
		sql = "`" + n.GetAlias() + "`"
	} else {
		sql = "`" + n.getParentNode().GetAlias() + "`.`" + n.name() + "`"
	}
	return
}

func (m_ *Mysql5) generateNodeListSql(nodes []NodeI, useAlias bool) (sql string, args []interface{}) {
	for _, node := range nodes {
		s, a := m_.I().(Mysql5I).generateNodeSql(node, useAlias)
		sql += s + ","
		args = append(args, a...)
	}
	sql = strings.TrimSuffix(sql, ",")
	return
}

func (m_ *Mysql5) generateOrderBySql(b *sqlBuilder) (sql string, args []interface{}) {
	if b.orderBys != nil && len(b.orderBys) > 0 {
		sql = "ORDER BY "
		for _, n := range b.orderBys {
			s, a := m_.I().(Mysql5I).generateNodeSql(n, true)
			if sorter, ok := n.(NodeSorter); ok {
				if sorter.sortDesc() {
					s += " DESC"
				}
			}
			sql += s + ","
			args = append(args, a...)
		}
		sql = strings.TrimSuffix(sql, ",")
		sql += "\n"
	}
	return
}

func (m_ *Mysql5) generateGroupBySql(b *sqlBuilder) (sql string, args []interface{}) {
	if b.groupBys != nil && len(b.groupBys) > 0 {
		sql = "GROUP BY "
		for _, n := range b.groupBys {
			s, a := m_.I().(Mysql5I).generateNodeSql(n, true)
			sql += s + ","
			args = append(args, a...)
		}
		sql = strings.TrimSuffix(sql, ",")
		sql += "\n"
	}
	return
}

func (m_ *Mysql5) generateWhereSql(b *sqlBuilder) (sql string, args []interface{}) {
	if b.condition != nil {
		sql = "WHERE "
		var s string
		s, args = m_.I().(Mysql5I).generateNodeSql(b.condition, false)
		sql += s + "\n"
	}
	return
}

func (m_ *Mysql5) generateHaving(b *sqlBuilder) (sql string, args []interface{}) {
	if b.having != nil {
		sql = "HAVING "
		var s string
		s, args = m_.I().(Mysql5I).generateNodeSql(b.having, false)
		sql += s + "\n"
	}
	return
}

func (m_ *Mysql5) generateLimitSql(b *sqlBuilder) (sql string) {
	if b.limitInfo == nil {
		return ""
	}
	if b.limitInfo.offset > 0 {
		sql = strconv.FormatInt(b.limitInfo.offset, 10) + ","
	}

	if b.limitInfo.maxRowCount > -1 {
		sql += strconv.FormatInt(b.limitInfo.maxRowCount, 10)
	}

	if sql != "" {
		sql = "LIMIT " + sql + "\n"
	}

	return
}

func (m_ *Mysql5) Update(ctx context.Context, table string, fields map[string]interface{}, pkName string, pkValue string) {
	var sql = "UPDATE " + table + "\n"
	var args = []interface{}{}
	s, a := m_.I().(Mysql5I).makeSetSql(fields)
	sql += s
	args = append(args, a...)

	sql += "WHERE " + pkName + " = ?"
	args = append(args, pkValue)
	_, e := m_.I().(Mysql5I).Exec(ctx, sql, args...)
	if e != nil {
		panic(e.Error())
	}
}

func (m_ *Mysql5) Insert(ctx context.Context, table string, fields map[string]interface{}) string {
	var sql = "INSERT " + table + "\n"
	var args = []interface{}{}
	s, a := m_.I().(Mysql5I).makeSetSql(fields)
	sql += s
	args = append(args, a...)

	if r, err := m_.I().(Mysql5I).Exec(ctx, sql, args...); err != nil {
		panic(err.Error())
	} else {
		if id, err := r.LastInsertId(); err != nil {
			panic(err.Error())
			return ""
		} else {
			return fmt.Sprint(id)
		}
	}
}

func (m_ *Mysql5) Delete(ctx context.Context, table string, pkName string, pkValue interface{}) {
	var sql = "DELETE FROM " + table + "\n"
	var args = []interface{}{}
	sql += "WHERE " + pkName + " = ?"
	args = append(args, pkValue)
	_, e := m_.I().(Mysql5I).Exec(ctx, sql, args...)
	if e != nil {
		panic(e.Error())
	}
}

func (m_ *Mysql5) makeSetSql(fields map[string]interface{}) (sql string, args []interface{}) {
	if len(fields) == 0 {
		panic("No fields to set")
	}
	sql = "SET "
	for k, v := range fields {
		sql += fmt.Sprintf("%s=?, ", k)
		args = append(args, v)
	}

	sql = strings.TrimSuffix(sql, ", ")
	sql += "\n"
	return
}

func (m_ *Mysql5) IsA(className string) bool {
	if className == "Mysql5" {
		return true
	}
	return m_.SqlDb.IsA(className)
}

func (m_ *Mysql5) Class() string {
	return "Mysql5"
}
