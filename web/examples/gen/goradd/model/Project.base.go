package model

// Code generated by goradd. DO NOT EDIT.

import (
	"context"
	"fmt"

	"github.com/goradd/goradd/pkg/orm/broadcast"
	"github.com/goradd/goradd/pkg/orm/db"
	. "github.com/goradd/goradd/pkg/orm/op"
	"github.com/goradd/goradd/pkg/orm/query"
	"github.com/goradd/goradd/pkg/stringmap"
	"github.com/goradd/goradd/web/examples/gen/goradd/model/node"

	//"./node"
	"bytes"
	"encoding/gob"
	"encoding/json"

	"github.com/goradd/goradd/pkg/datetime"
)

// projectBase is a base structure to be embedded in a "subclass" and provides the ORM access to the database.
// Do not directly access the internal variables, but rather use the accessor functions, since this class maintains internal state
// related to the variables.

type projectBase struct {
	id        string
	idIsValid bool
	idIsDirty bool

	num        int
	numIsValid bool
	numIsDirty bool

	projectStatusTypeID        uint
	projectStatusTypeIDIsValid bool
	projectStatusTypeIDIsDirty bool

	managerID        string
	managerIDIsNull  bool
	managerIDIsValid bool
	managerIDIsDirty bool
	oManager         *Person

	name        string
	nameIsValid bool
	nameIsDirty bool

	description        string
	descriptionIsNull  bool
	descriptionIsValid bool
	descriptionIsDirty bool

	startDate        datetime.DateTime
	startDateIsNull  bool
	startDateIsValid bool
	startDateIsDirty bool

	endDate        datetime.DateTime
	endDateIsNull  bool
	endDateIsValid bool
	endDateIsDirty bool

	budget        string
	budgetIsNull  bool
	budgetIsValid bool
	budgetIsDirty bool

	spent        string
	spentIsNull  bool
	spentIsValid bool
	spentIsDirty bool

	// Reverse reference objects.
	oMilestones []*Milestone          // Objects in the order they were queried
	mMilestones map[string]*Milestone // Objects by PK

	// Many-Many reference objects.
	oChildrenAsParent []*Project
	mChildrenAsParent map[string]*Project // Objects by PK
	oParentsAsChild   []*Project
	mParentsAsChild   map[string]*Project // Objects by PK
	oTeamMembers      []*Person
	mTeamMembers      map[string]*Person // Objects by PK

	// Custom aliases, if specified
	_aliases map[string]interface{}

	// Indicates whether this is a new object, or one loaded from the database. Used by Save to know whether to Insert or Update
	_restored bool
}

const (
	ProjectIDDefault                  = ""
	ProjectNumDefault                 = 0
	ProjectProjectStatusTypeIDDefault = 0
	ProjectManagerIDDefault           = ""
	ProjectNameDefault                = ""
	ProjectDescriptionDefault         = ""
	ProjectStartDateDefault           = datetime.Zero
	ProjectEndDateDefault             = datetime.Zero
	ProjectBudgetDefault              = ""
	ProjectSpentDefault               = ""
)

const (
	ProjectID                  = `ID`
	ProjectNum                 = `Num`
	ProjectProjectStatusTypeID = `ProjectStatusTypeID`
	ProjectProjectStatusType   = `ProjectStatusType`
	ProjectManagerID           = `ManagerID`
	ProjectManager             = `Manager`
	ProjectName                = `Name`
	ProjectDescription         = `Description`
	ProjectStartDate           = `StartDate`
	ProjectEndDate             = `EndDate`
	ProjectBudget              = `Budget`
	ProjectSpent               = `Spent`
	ProjectMilestones          = `Milestones`
	ProjectChildAsParent       = `ChildAsParent`
	ProjectChildrenAsParent    = `ChildrenAsParent`
	ProjectParentAsChild       = `ParentAsChild`
	ProjectParentsAsChild      = `ParentsAsChild`
	ProjectTeamMember          = `TeamMember`
	ProjectTeamMembers         = `TeamMembers`
)

// Initialize or re-initialize a Project database object to default values.
func (o *projectBase) Initialize() {

	o.id = ""
	o.idIsValid = false
	o.idIsDirty = false

	o.num = 0
	o.numIsValid = false
	o.numIsDirty = false

	o.projectStatusTypeID = 0
	o.projectStatusTypeIDIsValid = false
	o.projectStatusTypeIDIsDirty = false

	o.managerID = ""
	o.managerIDIsNull = true
	o.managerIDIsValid = true
	o.managerIDIsDirty = true

	o.name = ""
	o.nameIsValid = false
	o.nameIsDirty = false

	o.description = ""
	o.descriptionIsNull = true
	o.descriptionIsValid = true
	o.descriptionIsDirty = true

	o.startDate = datetime.DateTime{}
	o.startDateIsNull = true
	o.startDateIsValid = true
	o.startDateIsDirty = true

	o.endDate = datetime.DateTime{}
	o.endDateIsNull = true
	o.endDateIsValid = true
	o.endDateIsDirty = true

	o.budget = ""
	o.budgetIsNull = true
	o.budgetIsValid = true
	o.budgetIsDirty = true

	o.spent = ""
	o.spentIsNull = true
	o.spentIsValid = true
	o.spentIsDirty = true

	o._restored = false
}

func (o *projectBase) PrimaryKey() string {
	return o.id
}

// ID returns the loaded value of ID.
func (o *projectBase) ID() string {
	return fmt.Sprint(o.id)
}

// IDIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) IDIsValid() bool {
	return o._restored && o.idIsValid
}

func (o *projectBase) Num() int {
	if o._restored && !o.numIsValid {
		panic("num was not selected in the last query and so is not valid")
	}
	return o.num
}

// NumIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) NumIsValid() bool {
	return o.numIsValid
}

// SetNum sets the value of Num in the object, to be saved later using the Save() function.
func (o *projectBase) SetNum(v int) {
	o.numIsValid = true
	if o.num != v || !o._restored {
		o.num = v
		o.numIsDirty = true
	}

}

func (o *projectBase) ManagerID() string {
	if o._restored && !o.managerIDIsValid {
		panic("managerID was not selected in the last query and so is not valid")
	}
	return o.managerID
}

// ManagerIDIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) ManagerIDIsValid() bool {
	return o.managerIDIsValid
}

// ManagerIDIsNull returns true if the related database value is null.
func (o *projectBase) ManagerIDIsNull() bool {
	return o.managerIDIsNull
}

// Manager returns the current value of the loaded Manager, and nil if its not loaded.
func (o *projectBase) Manager() *Person {
	return o.oManager
}

// LoadManager returns the related Manager. If it is not already loaded,
// it will attempt to load it first.
func (o *projectBase) LoadManager(ctx context.Context) *Person {
	if !o.managerIDIsValid {
		return nil
	}

	if o.oManager == nil {
		// Load and cache
		o.oManager = LoadPerson(ctx, o.ManagerID())
	}
	return o.oManager
}

func (o *projectBase) SetManagerID(i interface{}) {
	o.managerIDIsValid = true
	if i == nil {
		if !o.managerIDIsNull {
			o.managerIDIsNull = true
			o.managerIDIsDirty = true
			o.managerID = ""
			o.oManager = nil
		}
	} else {
		v := i.(string)
		if o.managerIDIsNull ||
			!o._restored ||
			o.managerID != v {

			o.managerIDIsNull = false
			o.managerID = v
			o.managerIDIsDirty = true
			o.oManager = nil
		}
	}
}

func (o *projectBase) SetManager(v *Person) {
	o.managerIDIsValid = true
	if v == nil {
		if !o.managerIDIsNull || !o._restored {
			o.managerIDIsNull = true
			o.managerIDIsDirty = true
			o.managerID = ""
			o.oManager = nil
		}
	} else {
		o.oManager = v
		if o.managerIDIsNull || !o._restored || o.managerID != v.PrimaryKey() {
			o.managerIDIsNull = false
			o.managerID = v.PrimaryKey()
			o.managerIDIsDirty = true
		}
	}
}

func (o *projectBase) Name() string {
	if o._restored && !o.nameIsValid {
		panic("name was not selected in the last query and so is not valid")
	}
	return o.name
}

// NameIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) NameIsValid() bool {
	return o.nameIsValid
}

// SetName sets the value of Name in the object, to be saved later using the Save() function.
func (o *projectBase) SetName(v string) {
	o.nameIsValid = true
	if o.name != v || !o._restored {
		o.name = v
		o.nameIsDirty = true
	}

}

func (o *projectBase) Description() string {
	if o._restored && !o.descriptionIsValid {
		panic("description was not selected in the last query and so is not valid")
	}
	return o.description
}

// DescriptionIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) DescriptionIsValid() bool {
	return o.descriptionIsValid
}

// DescriptionIsNull returns true if the related database value is null.
func (o *projectBase) DescriptionIsNull() bool {
	return o.descriptionIsNull
}

func (o *projectBase) SetDescription(i interface{}) {
	o.descriptionIsValid = true
	if i == nil {
		if !o.descriptionIsNull {
			o.descriptionIsNull = true
			o.descriptionIsDirty = true
			o.description = ""
		}
	} else {
		v := i.(string)
		if o.descriptionIsNull ||
			!o._restored ||
			o.description != v {

			o.descriptionIsNull = false
			o.description = v
			o.descriptionIsDirty = true
		}
	}
}

func (o *projectBase) StartDate() datetime.DateTime {
	if o._restored && !o.startDateIsValid {
		panic("startDate was not selected in the last query and so is not valid")
	}
	return o.startDate
}

// StartDateIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) StartDateIsValid() bool {
	return o.startDateIsValid
}

// StartDateIsNull returns true if the related database value is null.
func (o *projectBase) StartDateIsNull() bool {
	return o.startDateIsNull
}

func (o *projectBase) SetStartDate(i interface{}) {
	o.startDateIsValid = true
	if i == nil {
		if !o.startDateIsNull {
			o.startDateIsNull = true
			o.startDateIsDirty = true
			o.startDate = datetime.DateTime{}
		}
	} else {
		v := i.(datetime.DateTime)
		if o.startDateIsNull ||
			!o._restored ||
			o.startDate != v {

			o.startDateIsNull = false
			o.startDate = v
			o.startDateIsDirty = true
		}
	}
}

func (o *projectBase) EndDate() datetime.DateTime {
	if o._restored && !o.endDateIsValid {
		panic("endDate was not selected in the last query and so is not valid")
	}
	return o.endDate
}

// EndDateIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) EndDateIsValid() bool {
	return o.endDateIsValid
}

// EndDateIsNull returns true if the related database value is null.
func (o *projectBase) EndDateIsNull() bool {
	return o.endDateIsNull
}

func (o *projectBase) SetEndDate(i interface{}) {
	o.endDateIsValid = true
	if i == nil {
		if !o.endDateIsNull {
			o.endDateIsNull = true
			o.endDateIsDirty = true
			o.endDate = datetime.DateTime{}
		}
	} else {
		v := i.(datetime.DateTime)
		if o.endDateIsNull ||
			!o._restored ||
			o.endDate != v {

			o.endDateIsNull = false
			o.endDate = v
			o.endDateIsDirty = true
		}
	}
}

func (o *projectBase) Budget() string {
	if o._restored && !o.budgetIsValid {
		panic("budget was not selected in the last query and so is not valid")
	}
	return o.budget
}

// BudgetIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) BudgetIsValid() bool {
	return o.budgetIsValid
}

// BudgetIsNull returns true if the related database value is null.
func (o *projectBase) BudgetIsNull() bool {
	return o.budgetIsNull
}

func (o *projectBase) SetBudget(i interface{}) {
	o.budgetIsValid = true
	if i == nil {
		if !o.budgetIsNull {
			o.budgetIsNull = true
			o.budgetIsDirty = true
			o.budget = ""
		}
	} else {
		v := i.(string)
		if o.budgetIsNull ||
			!o._restored ||
			o.budget != v {

			o.budgetIsNull = false
			o.budget = v
			o.budgetIsDirty = true
		}
	}
}

func (o *projectBase) Spent() string {
	if o._restored && !o.spentIsValid {
		panic("spent was not selected in the last query and so is not valid")
	}
	return o.spent
}

// SpentIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) SpentIsValid() bool {
	return o.spentIsValid
}

// SpentIsNull returns true if the related database value is null.
func (o *projectBase) SpentIsNull() bool {
	return o.spentIsNull
}

func (o *projectBase) SetSpent(i interface{}) {
	o.spentIsValid = true
	if i == nil {
		if !o.spentIsNull {
			o.spentIsNull = true
			o.spentIsDirty = true
			o.spent = ""
		}
	} else {
		v := i.(string)
		if o.spentIsNull ||
			!o._restored ||
			o.spent != v {

			o.spentIsNull = false
			o.spent = v
			o.spentIsDirty = true
		}
	}
}

// GetAlias returns the alias for the given key.
func (o *projectBase) GetAlias(key string) query.AliasValue {
	if a, ok := o._aliases[key]; ok {
		return query.NewAliasValue(a)
	} else {
		panic("Alias " + key + " not found.")
		return query.NewAliasValue([]byte{})
	}
}

func (o *projectBase) ProjectStatusType() ProjectStatusType {
	if o._restored && !o.projectStatusTypeIDIsValid {
		panic("projectStatusTypeID was not selected in the last query and so is not valid")
	}
	return ProjectStatusType(o.projectStatusTypeID)
}

func (o *projectBase) SetProjectStatusType(v ProjectStatusType) {
	if o.projectStatusTypeID != uint(v) {
		o.projectStatusTypeID = uint(v)
		o.projectStatusTypeIDIsDirty = true
		o.projectStatusTypeIDIsValid = true
	}
}

// ChildAsParent returns a single Project object, if one was loaded
// otherwise, it will return nil.
func (o *projectBase) ChildAsParent() *Project {
	if o.oChildrenAsParent == nil {
		return nil
	}
	return o.oChildrenAsParent[0]
}

// ChildrenAsParent returns a slice of Project objects if loaded. If not loaded, will return nil.
func (o *projectBase) ChildrenAsParent() []*Project {
	if o.oChildrenAsParent == nil {
		return nil
	}
	return o.oChildrenAsParent
}

// ParentAsChild returns a single Project object, if one was loaded
// otherwise, it will return nil.
func (o *projectBase) ParentAsChild() *Project {
	if o.oParentsAsChild == nil {
		return nil
	}
	return o.oParentsAsChild[0]
}

// ParentsAsChild returns a slice of Project objects if loaded. If not loaded, will return nil.
func (o *projectBase) ParentsAsChild() []*Project {
	if o.oParentsAsChild == nil {
		return nil
	}
	return o.oParentsAsChild
}

// TeamMember returns a single Person object, if one was loaded
// otherwise, it will return nil.
func (o *projectBase) TeamMember() *Person {
	if o.oTeamMembers == nil {
		return nil
	}
	return o.oTeamMembers[0]
}

// TeamMembers returns a slice of Person objects if loaded. If not loaded, will return nil.
func (o *projectBase) TeamMembers() []*Person {
	if o.oTeamMembers == nil {
		return nil
	}
	return o.oTeamMembers
}

// Milestone returns a single Milestone object by primary key, if one was loaded.
// Otherwise, it will return nil.
func (o *projectBase) Milestone(pk string) *Milestone {
	if o.oMilestones == nil || len(o.oMilestones) == 0 {
		return nil
	}
	v, _ := o.mMilestones[pk]
	return v
}

// Milestones returns a slice of Milestone objects if loaded.
func (o *projectBase) Milestones() []*Milestone {
	if o.oMilestones == nil {
		return nil
	}
	return o.oMilestones
}

// LoadMilestones loads a new slice of Milestone objects and returns it.
func (o *projectBase) LoadMilestones(ctx context.Context, conditions ...interface{}) []*Milestone {
	qb := queryMilestones(ctx)
	cond := Equal(node.Milestone().ProjectID(), o.PrimaryKey())
	if conditions != nil {
		conditions = append(conditions, cond)
		cond = And(conditions...)
	}

	o.oMilestones = qb.Where(cond).Load(ctx)
	return o.oMilestones
}

// Load returns a Project from the database.
// joinOrSelectNodes lets you provide nodes for joining to other tables or selecting specific fields. Table nodes will
// be considered Join nodes, and column nodes will be Select nodes. See Join() and Select() for more info.
func LoadProject(ctx context.Context, primaryKey string, joinOrSelectNodes ...query.NodeI) *Project {
	return queryProjects(ctx).Where(Equal(node.Project().ID(), primaryKey)).joinOrSelect(joinOrSelectNodes...).Get(ctx)
}

// LoadProjectByNum queries for a single Project object by the given unique index values.
// joinOrSelectNodes lets you provide nodes for joining to other tables or selecting specific fields. Table nodes will
// be considered Join nodes, and column nodes will be Select nodes. See Join() and Select() for more info.
// If you need a more elaborate query, use QueryProjects() to start a query builder.
func LoadProjectByNum(ctx context.Context, num int, joinOrSelectNodes ...query.NodeI) *Project {
	return queryProjects(ctx).
		Where(Equal(node.Project().Num(), num)).
		joinOrSelect(joinOrSelectNodes...).
		Get(ctx)
}

// The ProjectsBuilder uses the QueryBuilderI interface from the database to build a query.
// All query operations go through this query builder.
// End a query by calling either Load, Count, or Delete
type ProjectsBuilder struct {
	base                query.QueryBuilderI
	hasConditionalJoins bool
}

func newProjectBuilder() *ProjectsBuilder {
	b := &ProjectsBuilder{
		base: db.GetDatabase("goradd").
			NewBuilder(),
	}
	return b.Join(node.Project())
}

// Load terminates the query builder, performs the query, and returns a slice of Project objects. If there are
// any errors, they are returned in the context object. If no results come back from the query, it will return
// an empty slice
func (b *ProjectsBuilder) Load(ctx context.Context) (projectSlice []*Project) {
	results := b.base.Load(ctx)
	if results == nil {
		return
	}
	for _, item := range results {
		o := new(Project)
		o.load(item, !b.hasConditionalJoins, o, nil, "")
		projectSlice = append(projectSlice, o)
	}
	return projectSlice
}

// LoadI terminates the query builder, performs the query, and returns a slice of interfaces. If there are
// any errors, they are returned in the context object. If no results come back from the query, it will return
// an empty slice.
func (b *ProjectsBuilder) LoadI(ctx context.Context) (projectSlice []interface{}) {
	results := b.base.Load(ctx)
	if results == nil {
		return
	}
	for _, item := range results {
		o := new(Project)
		o.load(item, !b.hasConditionalJoins, o, nil, "")
		projectSlice = append(projectSlice, o)
	}
	return projectSlice
}

// Get is a convenience method to return only the first item found in a query. It is equivalent to adding
// Limit(1,0) to the query, and then getting the first item from the returned slice.
// Limits with joins do not currently work, so don't try it if you have a join
// TODO: Change this to Load1 to be more descriptive and avoid confusion with other Getters
func (b *ProjectsBuilder) Get(ctx context.Context) *Project {
	results := b.Limit(1, 0).Load(ctx)
	if results != nil && len(results) > 0 {
		obj := results[0]
		return obj
	} else {
		return nil
	}
}

// Expand expands an array type node so that it will produce individual rows instead of an array of items
func (b *ProjectsBuilder) Expand(n query.NodeI) *ProjectsBuilder {
	b.base.Expand(n)
	return b
}

// Join adds a node to the node tree so that its fields will appear in the query. Optionally add conditions to filter
// what gets included. The conditions will be AND'd with the basic condition matching the primary keys of the join.
func (b *ProjectsBuilder) Join(n query.NodeI, conditions ...query.NodeI) *ProjectsBuilder {
	var condition query.NodeI
	if len(conditions) > 1 {
		condition = And(conditions)
	} else if len(conditions) == 1 {
		condition = conditions[0]
	}
	b.base.Join(n, condition)
	if condition != nil {
		b.hasConditionalJoins = true
	}
	return b
}

// Where adds a condition to filter what gets selected.
func (b *ProjectsBuilder) Where(c query.NodeI) *ProjectsBuilder {
	b.base.Condition(c)
	return b
}

// OrderBy specifies how the resulting data should be sorted.
func (b *ProjectsBuilder) OrderBy(nodes ...query.NodeI) *ProjectsBuilder {
	b.base.OrderBy(nodes...)
	return b
}

// Limit will return a subset of the data, limited to the offset and number of rows specified
func (b *ProjectsBuilder) Limit(maxRowCount int, offset int) *ProjectsBuilder {
	b.base.Limit(maxRowCount, offset)
	return b
}

// Select optimizes the query to only return the specified fields. Once you put a Select in your query, you must
// specify all the fields that you will eventually read out. Be careful when selecting fields in joined tables, as joined
// tables will also contain pointers back to the parent table, and so the parent node should have the same field selected
// as the child node if you are querying those fields.
func (b *ProjectsBuilder) Select(nodes ...query.NodeI) *ProjectsBuilder {
	b.base.Select(nodes...)
	return b
}

// Alias lets you add a node with a custom name. After the query, you can read out the data using GetAlias() on a
// returned object. Alias is useful for adding calculations or subqueries to the query.
func (b *ProjectsBuilder) Alias(name string, n query.NodeI) *ProjectsBuilder {
	b.base.Alias(name, n)
	return b
}

// Distinct removes duplicates from the results of the query. Adding a Select() may help you get to the data you want, although
// using Distinct with joined tables is often not effective, since we force joined tables to include primary keys in the query, and this
// often ruins the effect of Distinct.
func (b *ProjectsBuilder) Distinct() *ProjectsBuilder {
	b.base.Distinct()
	return b
}

// GroupBy controls how results are grouped when using aggregate functions in an Alias() call.
func (b *ProjectsBuilder) GroupBy(nodes ...query.NodeI) *ProjectsBuilder {
	b.base.GroupBy(nodes...)
	return b
}

// Having does additional filtering on the results of the query.
func (b *ProjectsBuilder) Having(node query.NodeI) *ProjectsBuilder {
	b.base.Having(node)
	return b
}

// Count terminates a query and returns just the number of items selected.
func (b *ProjectsBuilder) Count(ctx context.Context, distinct bool, nodes ...query.NodeI) uint {
	return b.base.Count(ctx, distinct, nodes...)
}

// Delete uses the query builder to delete a group of records that match the criteria
func (b *ProjectsBuilder) Delete(ctx context.Context) {
	b.base.Delete(ctx)
}

// Subquery uses the query builder to define a subquery within a larger query. You MUST include what
// you are selecting by adding Alias or Select functions on the subquery builder. Generally you would use
// this as a node to an Alias function on the surrounding query builder.
func (b *ProjectsBuilder) Subquery() *query.SubqueryNode {
	return b.base.Subquery()
}

// joinOrSelect is a private helper function for the Load* functions
func (b *ProjectsBuilder) joinOrSelect(nodes ...query.NodeI) *ProjectsBuilder {
	for _, n := range nodes {
		switch n.(type) {
		case query.TableNodeI:
			b.base.Join(n, nil)
		case *query.ColumnNode:
			b.Select(n)
		}
	}
	return b
}

func CountProjectByID(ctx context.Context, id string) uint {
	return queryProjects(ctx).Where(Equal(node.Project().ID(), id)).Count(ctx, false)
}

func CountProjectByNum(ctx context.Context, num int) uint {
	return queryProjects(ctx).Where(Equal(node.Project().Num(), num)).Count(ctx, false)
}

func CountProjectByProjectStatusTypeID(ctx context.Context, projectStatusTypeID uint) uint {
	return queryProjects(ctx).Where(Equal(node.Project().ProjectStatusTypeID(), projectStatusTypeID)).Count(ctx, false)
}

func CountProjectByManagerID(ctx context.Context, managerID string) uint {
	return queryProjects(ctx).Where(Equal(node.Project().ManagerID(), managerID)).Count(ctx, false)
}

func CountProjectByName(ctx context.Context, name string) uint {
	return queryProjects(ctx).Where(Equal(node.Project().Name(), name)).Count(ctx, false)
}

func CountProjectByDescription(ctx context.Context, description string) uint {
	return queryProjects(ctx).Where(Equal(node.Project().Description(), description)).Count(ctx, false)
}

func CountProjectByStartDate(ctx context.Context, startDate datetime.DateTime) uint {
	return queryProjects(ctx).Where(Equal(node.Project().StartDate(), startDate)).Count(ctx, false)
}

func CountProjectByEndDate(ctx context.Context, endDate datetime.DateTime) uint {
	return queryProjects(ctx).Where(Equal(node.Project().EndDate(), endDate)).Count(ctx, false)
}

func CountProjectByBudget(ctx context.Context, budget string) uint {
	return queryProjects(ctx).Where(Equal(node.Project().Budget(), budget)).Count(ctx, false)
}

func CountProjectBySpent(ctx context.Context, spent string) uint {
	return queryProjects(ctx).Where(Equal(node.Project().Spent(), spent)).Count(ctx, false)
}

// load is the private loader that transforms data coming from the database into a tree structure reflecting the relationships
// between the object chain requested by the user in the query.
// If linkParent is true we will have child relationships use a pointer back to the parent object. If false, it will create a separate object.
// Care must be taken in the query, as Select clauses might not be honored if the child object has fields selected which the parent object does not have.
// Also, if any joins are conditional, that might affect which child objects are included, so in this situation, linkParent should be false
func (o *projectBase) load(m map[string]interface{}, linkParent bool, objThis *Project, objParent interface{}, parentKey string) {
	if v, ok := m["id"]; ok && v != nil {
		if o.id, ok = v.(string); ok {
			o.idIsValid = true
			o.idIsDirty = false
		} else {
			panic("Wrong type found for id.")
		}
	} else {
		o.idIsValid = false
		o.id = ""
	}

	if v, ok := m["num"]; ok && v != nil {
		if o.num, ok = v.(int); ok {
			o.numIsValid = true
			o.numIsDirty = false
		} else {
			panic("Wrong type found for num.")
		}
	} else {
		o.numIsValid = false
		o.num = 0
	}

	if v, ok := m["project_status_type_id"]; ok && v != nil {
		if o.projectStatusTypeID, ok = v.(uint); ok {
			o.projectStatusTypeIDIsValid = true
			o.projectStatusTypeIDIsDirty = false
		} else {
			panic("Wrong type found for project_status_type_id.")
		}
	} else {
		o.projectStatusTypeIDIsValid = false
		o.projectStatusTypeID = 0
	}

	if v, ok := m["manager_id"]; ok {
		if v == nil {
			o.managerID = ""
			o.managerIDIsNull = true
			o.managerIDIsValid = true
			o.managerIDIsDirty = false
		} else if o.managerID, ok = v.(string); ok {
			o.managerIDIsNull = false
			o.managerIDIsValid = true
			o.managerIDIsDirty = false
		} else {
			panic("Wrong type found for manager_id.")
		}
	} else {
		o.managerIDIsValid = false
		o.managerIDIsNull = true
		o.managerID = ""
	}
	if linkParent && parentKey == "Manager" {
		o.oManager = objParent.(*Person)
		o.managerIDIsValid = true
		o.managerIDIsDirty = false
	} else if v, ok := m["Manager"]; ok {
		if oManager, ok2 := v.(map[string]interface{}); ok2 {
			o.oManager = new(Person)
			o.oManager.load(oManager, linkParent, o.oManager, objThis, "ProjectsAsManager")
			o.managerIDIsValid = true
			o.managerIDIsDirty = false
		} else {
			panic("Wrong type found for oManager object.")
		}
	} else {
		o.oManager = nil
	}

	if v, ok := m["name"]; ok && v != nil {
		if o.name, ok = v.(string); ok {
			o.nameIsValid = true
			o.nameIsDirty = false
		} else {
			panic("Wrong type found for name.")
		}
	} else {
		o.nameIsValid = false
		o.name = ""
	}

	if v, ok := m["description"]; ok {
		if v == nil {
			o.description = ""
			o.descriptionIsNull = true
			o.descriptionIsValid = true
			o.descriptionIsDirty = false
		} else if o.description, ok = v.(string); ok {
			o.descriptionIsNull = false
			o.descriptionIsValid = true
			o.descriptionIsDirty = false
		} else {
			panic("Wrong type found for description.")
		}
	} else {
		o.descriptionIsValid = false
		o.descriptionIsNull = true
		o.description = ""
	}
	if v, ok := m["start_date"]; ok {
		if v == nil {
			o.startDate = datetime.DateTime{}
			o.startDateIsNull = true
			o.startDateIsValid = true
			o.startDateIsDirty = false
		} else if o.startDate, ok = v.(datetime.DateTime); ok {
			o.startDateIsNull = false
			o.startDateIsValid = true
			o.startDateIsDirty = false
		} else {
			panic("Wrong type found for start_date.")
		}
	} else {
		o.startDateIsValid = false
		o.startDateIsNull = true
		o.startDate = datetime.DateTime{}
	}
	if v, ok := m["end_date"]; ok {
		if v == nil {
			o.endDate = datetime.DateTime{}
			o.endDateIsNull = true
			o.endDateIsValid = true
			o.endDateIsDirty = false
		} else if o.endDate, ok = v.(datetime.DateTime); ok {
			o.endDateIsNull = false
			o.endDateIsValid = true
			o.endDateIsDirty = false
		} else {
			panic("Wrong type found for end_date.")
		}
	} else {
		o.endDateIsValid = false
		o.endDateIsNull = true
		o.endDate = datetime.DateTime{}
	}
	if v, ok := m["budget"]; ok {
		if v == nil {
			o.budget = ""
			o.budgetIsNull = true
			o.budgetIsValid = true
			o.budgetIsDirty = false
		} else if o.budget, ok = v.(string); ok {
			o.budgetIsNull = false
			o.budgetIsValid = true
			o.budgetIsDirty = false
		} else {
			panic("Wrong type found for budget.")
		}
	} else {
		o.budgetIsValid = false
		o.budgetIsNull = true
		o.budget = ""
	}
	if v, ok := m["spent"]; ok {
		if v == nil {
			o.spent = ""
			o.spentIsNull = true
			o.spentIsValid = true
			o.spentIsDirty = false
		} else if o.spent, ok = v.(string); ok {
			o.spentIsNull = false
			o.spentIsValid = true
			o.spentIsDirty = false
		} else {
			panic("Wrong type found for spent.")
		}
	} else {
		o.spentIsValid = false
		o.spentIsNull = true
		o.spent = ""
	}
	if v, ok := m["ChildrenAsParent"]; ok {
		if oChildrenAsParent, ok2 := v.([]db.ValueMap); ok2 {
			o.oChildrenAsParent = []*Project{}
			o.mChildrenAsParent = map[string]*Project{}

			for _, v2 := range oChildrenAsParent {
				obj := new(Project)
				obj.load(v2, linkParent, obj, objThis, "ParentsAsChild")
				if linkParent && parentKey == "ChildrenAsParent" && obj.id == objParent.(*Project).id {
					obj = objParent.(*Project)
				}
				o.oChildrenAsParent = append(o.oChildrenAsParent, obj)
				o.mChildrenAsParent[obj.PrimaryKey()] = obj
			}
		} else {
			panic("Wrong type found for oChildrenAsParent object.")
		}
	} else {
		o.oChildrenAsParent = nil
	}

	if v, ok := m["ParentsAsChild"]; ok {
		if oParentsAsChild, ok2 := v.([]db.ValueMap); ok2 {
			o.oParentsAsChild = []*Project{}
			o.mParentsAsChild = map[string]*Project{}

			for _, v2 := range oParentsAsChild {
				obj := new(Project)
				obj.load(v2, linkParent, obj, objThis, "ChildrenAsParent")
				if linkParent && parentKey == "ParentsAsChild" && obj.id == objParent.(*Project).id {
					obj = objParent.(*Project)
				}
				o.oParentsAsChild = append(o.oParentsAsChild, obj)
				o.mParentsAsChild[obj.PrimaryKey()] = obj
			}
		} else {
			panic("Wrong type found for oParentsAsChild object.")
		}
	} else {
		o.oParentsAsChild = nil
	}

	if v, ok := m["TeamMembers"]; ok {
		if oTeamMembers, ok2 := v.([]db.ValueMap); ok2 {
			o.oTeamMembers = []*Person{}
			o.mTeamMembers = map[string]*Person{}

			for _, v2 := range oTeamMembers {
				obj := new(Person)
				obj.load(v2, linkParent, obj, objThis, "ProjectsAsTeamMember")
				if linkParent && parentKey == "TeamMembers" && obj.id == objParent.(*Person).id {
					obj = objParent.(*Person)
				}
				o.oTeamMembers = append(o.oTeamMembers, obj)
				o.mTeamMembers[obj.PrimaryKey()] = obj
			}
		} else {
			panic("Wrong type found for oTeamMembers object.")
		}
	} else {
		o.oTeamMembers = nil
	}

	if v, ok := m["Milestones"]; ok {
		switch oMilestones := v.(type) {
		case []db.ValueMap:
			o.oMilestones = []*Milestone{}
			o.mMilestones = map[string]*Milestone{}
			for _, v2 := range oMilestones {
				obj := new(Milestone)
				obj.load(v2, linkParent, obj, objThis, "Project")
				if linkParent && parentKey == "Milestones" && obj.projectID == objParent.(*Milestone).projectID {
					obj = objParent.(*Milestone)
				}
				o.oMilestones = append(o.oMilestones, obj)
				o.mMilestones[obj.PrimaryKey()] = obj
			}
		case db.ValueMap: // single expansion
			obj := new(Milestone)
			obj.load(oMilestones, linkParent, obj, objThis, "Project")
			if linkParent && parentKey == "Milestones" && obj.projectID == objParent.(*Milestone).projectID {
				obj = objParent.(*Milestone)
			}
			o.oMilestones = []*Milestone{obj}
		default:
			panic("Wrong type found for oMilestones object.")
		}
	} else {
		o.oMilestones = nil
	}

	if v, ok := m["aliases_"]; ok {
		o._aliases = map[string]interface{}(v.(db.ValueMap))
	}
	o._restored = true
}

// Save will update or insert the object, depending on the state of the object.
// If it has any auto-generated ids, those will be updated.
func (o *projectBase) Save(ctx context.Context) {
	if o._restored {
		o.Update(ctx)
	} else {
		o.Insert(ctx)
	}
}

// Update will update the values in the database, saving any changed values.
func (o *projectBase) Update(ctx context.Context) {
	if !o._restored {
		panic("Cannot update a record that was not originally read from the database.")
	}
	m := o.getModifiedFields()
	if len(m) == 0 {
		return
	}
	d := db.GetDatabase("goradd")
	d.Update(ctx, "project", m, "id", fmt.Sprint(o.id))
	o.resetDirtyStatus()
	broadcast.Update(ctx, "goradd", "project", o.id, stringmap.SortedKeys(m)...)
}

// Insert forces the object to be inserted into the database. If the object was loaded from the database originally,
// this will create a duplicate in the database.
func (o *projectBase) Insert(ctx context.Context) {
	m := o.getModifiedFields()
	if len(m) == 0 {
		return
	}
	d := db.GetDatabase("goradd")
	id := d.Insert(ctx, "project", m)
	o.id = id
	o.resetDirtyStatus()
	o._restored = true
	broadcast.Insert(ctx, "goradd", "project", o.id)
}

func (o *projectBase) getModifiedFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
	if o.idIsDirty {
		fields["id"] = o.id
	}

	if o.numIsDirty {
		fields["num"] = o.num
	}

	if o.projectStatusTypeIDIsDirty {
		fields["project_status_type_id"] = o.projectStatusTypeID
	}

	if o.managerIDIsDirty {
		if o.managerIDIsNull {
			fields["manager_id"] = nil
		} else {
			fields["manager_id"] = o.managerID
		}
	}

	if o.nameIsDirty {
		fields["name"] = o.name
	}

	if o.descriptionIsDirty {
		if o.descriptionIsNull {
			fields["description"] = nil
		} else {
			fields["description"] = o.description
		}
	}

	if o.startDateIsDirty {
		if o.startDateIsNull {
			fields["start_date"] = nil
		} else {
			fields["start_date"] = o.startDate.GoTime()
		}
	}

	if o.endDateIsDirty {
		if o.endDateIsNull {
			fields["end_date"] = nil
		} else {
			fields["end_date"] = o.endDate.GoTime()
		}
	}

	if o.budgetIsDirty {
		if o.budgetIsNull {
			fields["budget"] = nil
		} else {
			fields["budget"] = o.budget
		}
	}

	if o.spentIsDirty {
		if o.spentIsNull {
			fields["spent"] = nil
		} else {
			fields["spent"] = o.spent
		}
	}

	return
}

// Delete deletes the associated record from the database.
func (o *projectBase) Delete(ctx context.Context) {
	if !o._restored {
		panic("Cannot delete a record that has no primary key value.")
	}
	d := db.GetDatabase("goradd")
	d.Delete(ctx, "project", "id", o.id)
	broadcast.Delete(ctx, "goradd", "project", o.id)
}

// deleteProject deletes the associated record from the database.
func deleteProject(ctx context.Context, pk string) {
	d := db.GetDatabase("goradd")
	d.Delete(ctx, "project", "id", pk)
	broadcast.Delete(ctx, "goradd", "project", pk)
}

func (o *projectBase) resetDirtyStatus() {
	o.idIsDirty = false
	o.numIsDirty = false
	o.projectStatusTypeIDIsDirty = false
	o.managerIDIsDirty = false
	o.nameIsDirty = false
	o.descriptionIsDirty = false
	o.startDateIsDirty = false
	o.endDateIsDirty = false
	o.budgetIsDirty = false
	o.spentIsDirty = false
}

func (o *projectBase) IsDirty() bool {
	return o.idIsDirty ||
		o.numIsDirty ||
		o.projectStatusTypeIDIsDirty ||
		o.managerIDIsDirty ||
		o.nameIsDirty ||
		o.descriptionIsDirty ||
		o.startDateIsDirty ||
		o.endDateIsDirty ||
		o.budgetIsDirty ||
		o.spentIsDirty
}

// Get returns the value of a field in the object based on the field's name.
// It will also get related objects if they are loaded.
// Invalid fields and objects are returned as nil
func (o *projectBase) Get(key string) interface{} {

	switch key {
	case "ID":
		if !o.idIsValid {
			return nil
		}
		return o.id

	case "Num":
		if !o.numIsValid {
			return nil
		}
		return o.num

	case "ProjectStatusTypeID":
		if !o.projectStatusTypeIDIsValid {
			return nil
		}
		return o.projectStatusTypeID

	case "ProjectStatusType":
		return o.ProjectStatusType()

	case "ManagerID":
		if !o.managerIDIsValid {
			return nil
		}
		return o.managerID

	case "Manager":
		return o.Manager()

	case "Name":
		if !o.nameIsValid {
			return nil
		}
		return o.name

	case "Description":
		if !o.descriptionIsValid {
			return nil
		}
		return o.description

	case "StartDate":
		if !o.startDateIsValid {
			return nil
		}
		return o.startDate

	case "EndDate":
		if !o.endDateIsValid {
			return nil
		}
		return o.endDate

	case "Budget":
		if !o.budgetIsValid {
			return nil
		}
		return o.budget

	case "Spent":
		if !o.spentIsValid {
			return nil
		}
		return o.spent

	case "Milestones":
		return o.Milestones()

	case "ChildAsParent":
		return o.ChildAsParent()
	case "ChildrenAsParent":
		return o.ChildrenAsParent()

	case "ParentAsChild":
		return o.ParentAsChild()
	case "ParentsAsChild":
		return o.ParentsAsChild()

	case "TeamMember":
		return o.TeamMember()
	case "TeamMembers":
		return o.TeamMembers()

	}
	return nil
}

// MarshalBinary serializes the object into a buffer that is deserializable using UnmarshalBinary.
// It should be used for transmitting database object over the wire, or for temporary storage. It does not send
// a version number, so if the data format changes, its up to you to invalidate the old stored objects.
// The framework uses this to serialize the object when it is stored in a control.
func (o *projectBase) MarshalBinary() ([]byte, error) {
	buf := new(bytes.Buffer)
	encoder := gob.NewEncoder(buf)

	if err := encoder.Encode(o.id); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.idIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.idIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.num); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.numIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.numIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.projectStatusTypeID); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.projectStatusTypeIDIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.projectStatusTypeIDIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.managerID); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.managerIDIsNull); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.managerIDIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.managerIDIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.oManager); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.name); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.nameIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.nameIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.description); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.descriptionIsNull); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.descriptionIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.descriptionIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.startDate); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.startDateIsNull); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.startDateIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.startDateIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.endDate); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.endDateIsNull); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.endDateIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.endDateIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.budget); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.budgetIsNull); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.budgetIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.budgetIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.spent); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.spentIsNull); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.spentIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.spentIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.oMilestones); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.oChildrenAsParent); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.oParentsAsChild); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.oTeamMembers); err != nil {
		return nil, err
	}

	if o._aliases == nil {
		if err := encoder.Encode(false); err != nil {
			return nil, err
		}
	} else {
		if err := encoder.Encode(true); err != nil {
			return nil, err
		}
		if err := encoder.Encode(o._aliases); err != nil {
			return nil, err
		}
	}

	if err := encoder.Encode(o._restored); err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func (o *projectBase) UnmarshalBinary(data []byte) (err error) {

	buf := bytes.NewBuffer(data)
	dec := gob.NewDecoder(buf)

	if err = dec.Decode(&o.id); err != nil {
		return
	}
	if err = dec.Decode(&o.idIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.idIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.num); err != nil {
		return
	}
	if err = dec.Decode(&o.numIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.numIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.projectStatusTypeID); err != nil {
		return
	}
	if err = dec.Decode(&o.projectStatusTypeIDIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.projectStatusTypeIDIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.managerID); err != nil {
		return
	}
	if err = dec.Decode(&o.managerIDIsNull); err != nil {
		return
	}
	if err = dec.Decode(&o.managerIDIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.managerIDIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.oManager); err != nil {
		return
	}
	if err = dec.Decode(&o.name); err != nil {
		return
	}
	if err = dec.Decode(&o.nameIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.nameIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.description); err != nil {
		return
	}
	if err = dec.Decode(&o.descriptionIsNull); err != nil {
		return
	}
	if err = dec.Decode(&o.descriptionIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.descriptionIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.startDate); err != nil {
		return
	}
	if err = dec.Decode(&o.startDateIsNull); err != nil {
		return
	}
	if err = dec.Decode(&o.startDateIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.startDateIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.endDate); err != nil {
		return
	}
	if err = dec.Decode(&o.endDateIsNull); err != nil {
		return
	}
	if err = dec.Decode(&o.endDateIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.endDateIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.budget); err != nil {
		return
	}
	if err = dec.Decode(&o.budgetIsNull); err != nil {
		return
	}
	if err = dec.Decode(&o.budgetIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.budgetIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.spent); err != nil {
		return
	}
	if err = dec.Decode(&o.spentIsNull); err != nil {
		return
	}
	if err = dec.Decode(&o.spentIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.spentIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.oMilestones); err != nil {
		return
	}
	if len(o.oMilestones) > 0 {
		o.mMilestones = make(map[string]*Milestone)
		for _, p := range o.oMilestones {
			o.mMilestones[p.PrimaryKey()] = p
		}
	}

	if err = dec.Decode(&o.oChildrenAsParent); err != nil {
		return
	}
	if len(o.oChildrenAsParent) > 0 {
		o.mChildrenAsParent = make(map[string]*Project)

		for _, p := range o.oChildrenAsParent {
			o.mChildrenAsParent[p.PrimaryKey()] = p
		}
	}
	if err = dec.Decode(&o.oParentsAsChild); err != nil {
		return
	}
	if len(o.oParentsAsChild) > 0 {
		o.mParentsAsChild = make(map[string]*Project)

		for _, p := range o.oParentsAsChild {
			o.mParentsAsChild[p.PrimaryKey()] = p
		}
	}
	if err = dec.Decode(&o.oTeamMembers); err != nil {
		return
	}
	if len(o.oTeamMembers) > 0 {
		o.mTeamMembers = make(map[string]*Person)

		for _, p := range o.oTeamMembers {
			o.mTeamMembers[p.PrimaryKey()] = p
		}
	}

	var hasAliases bool
	if err = dec.Decode(&hasAliases); err != nil {
		return
	}
	if hasAliases {
		if err = dec.Decode(&o._aliases); err != nil {
			return
		}
	}

	if err = dec.Decode(&o._restored); err != nil {
		return
	}

	return
}

// MarshalJSON serializes the object into a JSON object.
// Only valid data will be serialized, meaning, you can control what gets serialized by using Select to
// select only the fields you want when you query for the object.
func (o *projectBase) MarshalJSON() (data []byte, err error) {
	v := make(map[string]interface{})

	if o.idIsValid {
		v["id"] = o.id
	}

	if o.numIsValid {
		v["num"] = o.num
	}

	if o.projectStatusTypeIDIsValid {
		v["projectStatusTypeID"] = o.projectStatusTypeID
	}

	if o.projectStatusTypeIDIsValid {
		v["projectStatusType"] = o.ProjectStatusType().String()
	}
	if o.managerIDIsValid {
		if o.managerIDIsNull {
			v["managerID"] = nil
		} else {
			v["managerID"] = o.managerID
		}
	}

	if val := o.Manager(); val != nil {
		v["manager"] = val
	}
	if o.nameIsValid {
		v["name"] = o.name
	}

	if o.descriptionIsValid {
		if o.descriptionIsNull {
			v["description"] = nil
		} else {
			v["description"] = o.description
		}
	}

	if o.startDateIsValid {
		if o.startDateIsNull {
			v["startDate"] = nil
		} else {
			v["startDate"] = o.startDate
		}
	}

	if o.endDateIsValid {
		if o.endDateIsNull {
			v["endDate"] = nil
		} else {
			v["endDate"] = o.endDate
		}
	}

	if o.budgetIsValid {
		if o.budgetIsNull {
			v["budget"] = nil
		} else {
			v["budget"] = o.budget
		}
	}

	if o.spentIsValid {
		if o.spentIsNull {
			v["spent"] = nil
		} else {
			v["spent"] = o.spent
		}
	}

	if val := o.Milestones(); val != nil {
		v["project"] = val
	}

	if val := o.ChildrenAsParent(); val != nil {
		v["childrenAsParent"] = val
	}
	if val := o.ParentsAsChild(); val != nil {
		v["parentsAsChild"] = val
	}
	if val := o.TeamMembers(); val != nil {
		v["teamMembers"] = val
	}

	return json.Marshal(v)
}
