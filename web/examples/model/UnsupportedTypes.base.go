package model

// Code generated by goradd. DO NOT EDIT.

import (
	"context"
	"fmt"
	"github.com/goradd/goradd/web/examples/model/node"

	"github.com/goradd/goradd/pkg/orm/db"
	. "github.com/goradd/goradd/pkg/orm/op"
	"github.com/goradd/goradd/pkg/orm/query"

	//"./node"
	"bytes"
	"encoding/gob"
	"encoding/json"
)

// unsupportedTypesBase is a base structure to be embedded in a "subclass" and provides the ORM access to the database.
// Do not directly access the internal variables, but rather use the accessor functions, since this class maintains internal state
// related to the variables.

type unsupportedTypesBase struct {
	typeSet        string
	typeSetIsValid bool
	typeSetIsDirty bool

	typeEnum        string
	typeEnumIsValid bool
	typeEnumIsDirty bool

	typeDecimal        string
	typeDecimalIsValid bool
	typeDecimalIsDirty bool

	typeDouble        float64
	typeDoubleIsValid bool
	typeDoubleIsDirty bool

	typeGeo        string
	typeGeoIsValid bool
	typeGeoIsDirty bool

	typeTinyBlob        []byte
	typeTinyBlobIsValid bool
	typeTinyBlobIsDirty bool

	typeMediumBlob        []byte
	typeMediumBlobIsValid bool
	typeMediumBlobIsDirty bool

	typeVarbinary        string
	typeVarbinaryIsValid bool
	typeVarbinaryIsDirty bool

	typeLongtext        string
	typeLongtextIsValid bool
	typeLongtextIsDirty bool

	typeBinary        string
	typeBinaryIsValid bool
	typeBinaryIsDirty bool

	typeSmall        int
	typeSmallIsValid bool
	typeSmallIsDirty bool

	typeMedium        int
	typeMediumIsValid bool
	typeMediumIsDirty bool

	typeBig        int64
	typeBigIsValid bool
	typeBigIsDirty bool

	typePolygon        string
	typePolygonIsValid bool
	typePolygonIsDirty bool

	typeSerial        string
	typeSerialIsValid bool
	typeSerialIsDirty bool

	typeUnsigned        uint
	typeUnsignedIsValid bool
	typeUnsignedIsDirty bool

	typeMultfk1        string
	typeMultfk1IsValid bool
	typeMultfk1IsDirty bool

	typeMultifk2        string
	typeMultifk2IsValid bool
	typeMultifk2IsDirty bool

	// Custom aliases, if specified
	_aliases map[string]interface{}

	// Indicates whether this is a new object, or one loaded from the database. Used by Save to know whether to Insert or Update
	_restored bool
}

const (
	UnsupportedTypesTypeSetDefault       = ""
	UnsupportedTypesTypeEnumDefault      = ""
	UnsupportedTypesTypeDecimalDefault   = ""
	UnsupportedTypesTypeDoubleDefault    = 0.0
	UnsupportedTypesTypeGeoDefault       = ""
	UnsupportedTypesTypeVarbinaryDefault = ""
	UnsupportedTypesTypeLongtextDefault  = ""
	UnsupportedTypesTypeBinaryDefault    = ""
	UnsupportedTypesTypeSmallDefault     = 0
	UnsupportedTypesTypeMediumDefault    = 0
	UnsupportedTypesTypeBigDefault       = 0
	UnsupportedTypesTypePolygonDefault   = ""
	UnsupportedTypesTypeSerialDefault    = ""
	UnsupportedTypesTypeUnsignedDefault  = 0
	UnsupportedTypesTypeMultfk1Default   = ""
	UnsupportedTypesTypeMultifk2Default  = ""
)

const (
	UnsupportedTypesTypeSet        = `TypeSet`
	UnsupportedTypesTypeEnum       = `TypeEnum`
	UnsupportedTypesTypeDecimal    = `TypeDecimal`
	UnsupportedTypesTypeDouble     = `TypeDouble`
	UnsupportedTypesTypeGeo        = `TypeGeo`
	UnsupportedTypesTypeTinyBlob   = `TypeTinyBlob`
	UnsupportedTypesTypeMediumBlob = `TypeMediumBlob`
	UnsupportedTypesTypeVarbinary  = `TypeVarbinary`
	UnsupportedTypesTypeLongtext   = `TypeLongtext`
	UnsupportedTypesTypeBinary     = `TypeBinary`
	UnsupportedTypesTypeSmall      = `TypeSmall`
	UnsupportedTypesTypeMedium     = `TypeMedium`
	UnsupportedTypesTypeBig        = `TypeBig`
	UnsupportedTypesTypePolygon    = `TypePolygon`
	UnsupportedTypesTypeSerial     = `TypeSerial`
	UnsupportedTypesTypeUnsigned   = `TypeUnsigned`
	UnsupportedTypesTypeMultfk1    = `TypeMultfk1`
	UnsupportedTypesTypeMultifk2   = `TypeMultifk2`
)

// Initialize or re-initialize a UnsupportedTypes database object to default values.
func (o *unsupportedTypesBase) Initialize() {

	o.typeSet = ""
	o.typeSetIsValid = false
	o.typeSetIsDirty = false

	o.typeEnum = ""
	o.typeEnumIsValid = false
	o.typeEnumIsDirty = false

	o.typeDecimal = ""
	o.typeDecimalIsValid = false
	o.typeDecimalIsDirty = false

	o.typeDouble = 0.0
	o.typeDoubleIsValid = false
	o.typeDoubleIsDirty = false

	o.typeGeo = ""
	o.typeGeoIsValid = false
	o.typeGeoIsDirty = false

	o.typeTinyBlob = nil
	o.typeTinyBlobIsValid = false
	o.typeTinyBlobIsDirty = false

	o.typeMediumBlob = nil
	o.typeMediumBlobIsValid = false
	o.typeMediumBlobIsDirty = false

	o.typeVarbinary = ""
	o.typeVarbinaryIsValid = false
	o.typeVarbinaryIsDirty = false

	o.typeLongtext = ""
	o.typeLongtextIsValid = false
	o.typeLongtextIsDirty = false

	o.typeBinary = ""
	o.typeBinaryIsValid = false
	o.typeBinaryIsDirty = false

	o.typeSmall = 0
	o.typeSmallIsValid = false
	o.typeSmallIsDirty = false

	o.typeMedium = 0
	o.typeMediumIsValid = false
	o.typeMediumIsDirty = false

	o.typeBig = 0
	o.typeBigIsValid = false
	o.typeBigIsDirty = false

	o.typePolygon = ""
	o.typePolygonIsValid = false
	o.typePolygonIsDirty = false

	o.typeSerial = ""
	o.typeSerialIsValid = false
	o.typeSerialIsDirty = false

	o.typeUnsigned = 0
	o.typeUnsignedIsValid = false
	o.typeUnsignedIsDirty = false

	o.typeMultfk1 = ""
	o.typeMultfk1IsValid = false
	o.typeMultfk1IsDirty = false

	o.typeMultifk2 = ""
	o.typeMultifk2IsValid = false
	o.typeMultifk2IsDirty = false

	o._restored = false
}

func (o *unsupportedTypesBase) PrimaryKey() string {
	return o.typeSerial
}

func (o *unsupportedTypesBase) TypeSet() string {
	if o._restored && !o.typeSetIsValid {
		panic("typeSet was not selected in the last query and so is not valid")
	}
	return o.typeSet
}

// TypeSetIsValid returns true if the value was loaded from the database or has been set.
func (o *unsupportedTypesBase) TypeSetIsValid() bool {
	return o.typeSetIsValid
}

// SetTypeSet sets the value of TypeSet in the object, to be saved later using the Save() function.
func (o *unsupportedTypesBase) SetTypeSet(v string) {
	o.typeSetIsValid = true
	if o.typeSet != v || !o._restored {
		o.typeSet = v
		o.typeSetIsDirty = true
	}

}

func (o *unsupportedTypesBase) TypeEnum() string {
	if o._restored && !o.typeEnumIsValid {
		panic("typeEnum was not selected in the last query and so is not valid")
	}
	return o.typeEnum
}

// TypeEnumIsValid returns true if the value was loaded from the database or has been set.
func (o *unsupportedTypesBase) TypeEnumIsValid() bool {
	return o.typeEnumIsValid
}

// SetTypeEnum sets the value of TypeEnum in the object, to be saved later using the Save() function.
func (o *unsupportedTypesBase) SetTypeEnum(v string) {
	o.typeEnumIsValid = true
	if o.typeEnum != v || !o._restored {
		o.typeEnum = v
		o.typeEnumIsDirty = true
	}

}

func (o *unsupportedTypesBase) TypeDecimal() string {
	if o._restored && !o.typeDecimalIsValid {
		panic("typeDecimal was not selected in the last query and so is not valid")
	}
	return o.typeDecimal
}

// TypeDecimalIsValid returns true if the value was loaded from the database or has been set.
func (o *unsupportedTypesBase) TypeDecimalIsValid() bool {
	return o.typeDecimalIsValid
}

// SetTypeDecimal sets the value of TypeDecimal in the object, to be saved later using the Save() function.
func (o *unsupportedTypesBase) SetTypeDecimal(v string) {
	o.typeDecimalIsValid = true
	if o.typeDecimal != v || !o._restored {
		o.typeDecimal = v
		o.typeDecimalIsDirty = true
	}

}

func (o *unsupportedTypesBase) TypeDouble() float64 {
	if o._restored && !o.typeDoubleIsValid {
		panic("typeDouble was not selected in the last query and so is not valid")
	}
	return o.typeDouble
}

// TypeDoubleIsValid returns true if the value was loaded from the database or has been set.
func (o *unsupportedTypesBase) TypeDoubleIsValid() bool {
	return o.typeDoubleIsValid
}

// SetTypeDouble sets the value of TypeDouble in the object, to be saved later using the Save() function.
func (o *unsupportedTypesBase) SetTypeDouble(v float64) {
	o.typeDoubleIsValid = true
	if o.typeDouble != v || !o._restored {
		o.typeDouble = v
		o.typeDoubleIsDirty = true
	}

}

func (o *unsupportedTypesBase) TypeGeo() string {
	if o._restored && !o.typeGeoIsValid {
		panic("typeGeo was not selected in the last query and so is not valid")
	}
	return o.typeGeo
}

// TypeGeoIsValid returns true if the value was loaded from the database or has been set.
func (o *unsupportedTypesBase) TypeGeoIsValid() bool {
	return o.typeGeoIsValid
}

// SetTypeGeo sets the value of TypeGeo in the object, to be saved later using the Save() function.
func (o *unsupportedTypesBase) SetTypeGeo(v string) {
	o.typeGeoIsValid = true
	if o.typeGeo != v || !o._restored {
		o.typeGeo = v
		o.typeGeoIsDirty = true
	}

}

func (o *unsupportedTypesBase) TypeTinyBlob() []byte {
	if o._restored && !o.typeTinyBlobIsValid {
		panic("typeTinyBlob was not selected in the last query and so is not valid")
	}
	return o.typeTinyBlob
}

// TypeTinyBlobIsValid returns true if the value was loaded from the database or has been set.
func (o *unsupportedTypesBase) TypeTinyBlobIsValid() bool {
	return o.typeTinyBlobIsValid
}

// SetTypeTinyBlob sets the value of TypeTinyBlob in the object, to be saved later using the Save() function.
func (o *unsupportedTypesBase) SetTypeTinyBlob(v []byte) {
	o.typeTinyBlobIsValid = true
	o.typeTinyBlob = v // TODO: Copy bytes??
	o.typeTinyBlobIsDirty = true

}

func (o *unsupportedTypesBase) TypeMediumBlob() []byte {
	if o._restored && !o.typeMediumBlobIsValid {
		panic("typeMediumBlob was not selected in the last query and so is not valid")
	}
	return o.typeMediumBlob
}

// TypeMediumBlobIsValid returns true if the value was loaded from the database or has been set.
func (o *unsupportedTypesBase) TypeMediumBlobIsValid() bool {
	return o.typeMediumBlobIsValid
}

// SetTypeMediumBlob sets the value of TypeMediumBlob in the object, to be saved later using the Save() function.
func (o *unsupportedTypesBase) SetTypeMediumBlob(v []byte) {
	o.typeMediumBlobIsValid = true
	o.typeMediumBlob = v // TODO: Copy bytes??
	o.typeMediumBlobIsDirty = true

}

func (o *unsupportedTypesBase) TypeVarbinary() string {
	if o._restored && !o.typeVarbinaryIsValid {
		panic("typeVarbinary was not selected in the last query and so is not valid")
	}
	return o.typeVarbinary
}

// TypeVarbinaryIsValid returns true if the value was loaded from the database or has been set.
func (o *unsupportedTypesBase) TypeVarbinaryIsValid() bool {
	return o.typeVarbinaryIsValid
}

// SetTypeVarbinary sets the value of TypeVarbinary in the object, to be saved later using the Save() function.
func (o *unsupportedTypesBase) SetTypeVarbinary(v string) {
	o.typeVarbinaryIsValid = true
	if o.typeVarbinary != v || !o._restored {
		o.typeVarbinary = v
		o.typeVarbinaryIsDirty = true
	}

}

func (o *unsupportedTypesBase) TypeLongtext() string {
	if o._restored && !o.typeLongtextIsValid {
		panic("typeLongtext was not selected in the last query and so is not valid")
	}
	return o.typeLongtext
}

// TypeLongtextIsValid returns true if the value was loaded from the database or has been set.
func (o *unsupportedTypesBase) TypeLongtextIsValid() bool {
	return o.typeLongtextIsValid
}

// SetTypeLongtext sets the value of TypeLongtext in the object, to be saved later using the Save() function.
func (o *unsupportedTypesBase) SetTypeLongtext(v string) {
	o.typeLongtextIsValid = true
	if o.typeLongtext != v || !o._restored {
		o.typeLongtext = v
		o.typeLongtextIsDirty = true
	}

}

func (o *unsupportedTypesBase) TypeBinary() string {
	if o._restored && !o.typeBinaryIsValid {
		panic("typeBinary was not selected in the last query and so is not valid")
	}
	return o.typeBinary
}

// TypeBinaryIsValid returns true if the value was loaded from the database or has been set.
func (o *unsupportedTypesBase) TypeBinaryIsValid() bool {
	return o.typeBinaryIsValid
}

// SetTypeBinary sets the value of TypeBinary in the object, to be saved later using the Save() function.
func (o *unsupportedTypesBase) SetTypeBinary(v string) {
	o.typeBinaryIsValid = true
	if o.typeBinary != v || !o._restored {
		o.typeBinary = v
		o.typeBinaryIsDirty = true
	}

}

func (o *unsupportedTypesBase) TypeSmall() int {
	if o._restored && !o.typeSmallIsValid {
		panic("typeSmall was not selected in the last query and so is not valid")
	}
	return o.typeSmall
}

// TypeSmallIsValid returns true if the value was loaded from the database or has been set.
func (o *unsupportedTypesBase) TypeSmallIsValid() bool {
	return o.typeSmallIsValid
}

// SetTypeSmall sets the value of TypeSmall in the object, to be saved later using the Save() function.
func (o *unsupportedTypesBase) SetTypeSmall(v int) {
	o.typeSmallIsValid = true
	if o.typeSmall != v || !o._restored {
		o.typeSmall = v
		o.typeSmallIsDirty = true
	}

}

func (o *unsupportedTypesBase) TypeMedium() int {
	if o._restored && !o.typeMediumIsValid {
		panic("typeMedium was not selected in the last query and so is not valid")
	}
	return o.typeMedium
}

// TypeMediumIsValid returns true if the value was loaded from the database or has been set.
func (o *unsupportedTypesBase) TypeMediumIsValid() bool {
	return o.typeMediumIsValid
}

// SetTypeMedium sets the value of TypeMedium in the object, to be saved later using the Save() function.
func (o *unsupportedTypesBase) SetTypeMedium(v int) {
	o.typeMediumIsValid = true
	if o.typeMedium != v || !o._restored {
		o.typeMedium = v
		o.typeMediumIsDirty = true
	}

}

func (o *unsupportedTypesBase) TypeBig() int64 {
	if o._restored && !o.typeBigIsValid {
		panic("typeBig was not selected in the last query and so is not valid")
	}
	return o.typeBig
}

// TypeBigIsValid returns true if the value was loaded from the database or has been set.
func (o *unsupportedTypesBase) TypeBigIsValid() bool {
	return o.typeBigIsValid
}

// SetTypeBig sets the value of TypeBig in the object, to be saved later using the Save() function.
func (o *unsupportedTypesBase) SetTypeBig(v int64) {
	o.typeBigIsValid = true
	if o.typeBig != v || !o._restored {
		o.typeBig = v
		o.typeBigIsDirty = true
	}

}

func (o *unsupportedTypesBase) TypePolygon() string {
	if o._restored && !o.typePolygonIsValid {
		panic("typePolygon was not selected in the last query and so is not valid")
	}
	return o.typePolygon
}

// TypePolygonIsValid returns true if the value was loaded from the database or has been set.
func (o *unsupportedTypesBase) TypePolygonIsValid() bool {
	return o.typePolygonIsValid
}

// SetTypePolygon sets the value of TypePolygon in the object, to be saved later using the Save() function.
func (o *unsupportedTypesBase) SetTypePolygon(v string) {
	o.typePolygonIsValid = true
	if o.typePolygon != v || !o._restored {
		o.typePolygon = v
		o.typePolygonIsDirty = true
	}

}

// TypeSerial returns the loaded value of TypeSerial.
func (o *unsupportedTypesBase) TypeSerial() string {
	return fmt.Sprint(o.typeSerial)
}

// TypeSerialIsValid returns true if the value was loaded from the database or has been set.
func (o *unsupportedTypesBase) TypeSerialIsValid() bool {
	return o._restored && o.typeSerialIsValid
}

func (o *unsupportedTypesBase) TypeUnsigned() uint {
	if o._restored && !o.typeUnsignedIsValid {
		panic("typeUnsigned was not selected in the last query and so is not valid")
	}
	return o.typeUnsigned
}

// TypeUnsignedIsValid returns true if the value was loaded from the database or has been set.
func (o *unsupportedTypesBase) TypeUnsignedIsValid() bool {
	return o.typeUnsignedIsValid
}

// SetTypeUnsigned sets the value of TypeUnsigned in the object, to be saved later using the Save() function.
func (o *unsupportedTypesBase) SetTypeUnsigned(v uint) {
	o.typeUnsignedIsValid = true
	if o.typeUnsigned != v || !o._restored {
		o.typeUnsigned = v
		o.typeUnsignedIsDirty = true
	}

}

func (o *unsupportedTypesBase) TypeMultfk1() string {
	if o._restored && !o.typeMultfk1IsValid {
		panic("typeMultfk1 was not selected in the last query and so is not valid")
	}
	return o.typeMultfk1
}

// TypeMultfk1IsValid returns true if the value was loaded from the database or has been set.
func (o *unsupportedTypesBase) TypeMultfk1IsValid() bool {
	return o.typeMultfk1IsValid
}

// SetTypeMultfk1 sets the value of TypeMultfk1 in the object, to be saved later using the Save() function.
func (o *unsupportedTypesBase) SetTypeMultfk1(v string) {
	o.typeMultfk1IsValid = true
	if o.typeMultfk1 != v || !o._restored {
		o.typeMultfk1 = v
		o.typeMultfk1IsDirty = true
	}

}

func (o *unsupportedTypesBase) TypeMultifk2() string {
	if o._restored && !o.typeMultifk2IsValid {
		panic("typeMultifk2 was not selected in the last query and so is not valid")
	}
	return o.typeMultifk2
}

// TypeMultifk2IsValid returns true if the value was loaded from the database or has been set.
func (o *unsupportedTypesBase) TypeMultifk2IsValid() bool {
	return o.typeMultifk2IsValid
}

// SetTypeMultifk2 sets the value of TypeMultifk2 in the object, to be saved later using the Save() function.
func (o *unsupportedTypesBase) SetTypeMultifk2(v string) {
	o.typeMultifk2IsValid = true
	if o.typeMultifk2 != v || !o._restored {
		o.typeMultifk2 = v
		o.typeMultifk2IsDirty = true
	}

}

// GetAlias returns the alias for the given key.
func (o *unsupportedTypesBase) GetAlias(key string) query.AliasValue {
	if a, ok := o._aliases[key]; ok {
		return query.NewAliasValue(a)
	} else {
		panic("Alias " + key + " not found.")
		return query.NewAliasValue([]byte{})
	}
}

// Load returns a UnsupportedTypes from the database.
// joinOrSelectNodes lets you provide nodes for joining to other tables or selecting specific fields. Table nodes will
// be considered Join nodes, and column nodes will be Select nodes. See Join() and Select() for more info.
func LoadUnsupportedTypes(ctx context.Context, primaryKey string, joinOrSelectNodes ...query.NodeI) *UnsupportedTypes {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypeSerial(), primaryKey)).joinOrSelect(joinOrSelectNodes...).Get(ctx)
}

// LoadUnsupportedTypesByTypeSerial queries for a single UnsupportedTypes object by the given unique index values.
// joinOrSelectNodes lets you provide nodes for joining to other tables or selecting specific fields. Table nodes will
// be considered Join nodes, and column nodes will be Select nodes. See Join() and Select() for more info.
// If you need a more elaborate query, use QueryUnsupportedTypes() to start a query builder.
func LoadUnsupportedTypesByTypeSerial(ctx context.Context, type_serial string, joinOrSelectNodes ...query.NodeI) *UnsupportedTypes {
	return queryUnsupportedTypes(ctx).
		Where(Equal(node.UnsupportedTypes().TypeSerial(), type_serial)).
		joinOrSelect(joinOrSelectNodes...).
		Get(ctx)
}

// The UnsupportedTypesBuilder uses the QueryBuilderI interface from the database to build a query.
// All query operations go through this query builder.
// End a query by calling either Load, Count, or Delete
type UnsupportedTypesBuilder struct {
	base                query.QueryBuilderI
	hasConditionalJoins bool
}

func newUnsupportedTypesBuilder() *UnsupportedTypesBuilder {
	b := &UnsupportedTypesBuilder{
		base: db.GetDatabase("goradd").
			NewBuilder(),
	}
	return b.Join(node.UnsupportedTypes())
}

// Load terminates the query builder, performs the query, and returns a slice of UnsupportedTypes objects. If there are
// any errors, they are returned in the context object. If no results come back from the query, it will return
// an empty slice
func (b *UnsupportedTypesBuilder) Load(ctx context.Context) (unsupportedTypesSlice []*UnsupportedTypes) {
	results := b.base.Load(ctx)
	if results == nil {
		return
	}
	for _, item := range results {
		o := new(UnsupportedTypes)
		o.load(item, !b.hasConditionalJoins, o, nil, "")
		unsupportedTypesSlice = append(unsupportedTypesSlice, o)
	}
	return unsupportedTypesSlice
}

// LoadI terminates the query builder, performs the query, and returns a slice of interfaces. If there are
// any errors, they are returned in the context object. If no results come back from the query, it will return
// an empty slice.
func (b *UnsupportedTypesBuilder) LoadI(ctx context.Context) (unsupportedTypesSlice []interface{}) {
	results := b.base.Load(ctx)
	if results == nil {
		return
	}
	for _, item := range results {
		o := new(UnsupportedTypes)
		o.load(item, !b.hasConditionalJoins, o, nil, "")
		unsupportedTypesSlice = append(unsupportedTypesSlice, o)
	}
	return unsupportedTypesSlice
}

// Get is a convenience method to return only the first item found in a query. It is equivalent to adding
// Limit(1,0) to the query, and then getting the first item from the returned slice.
// Limits with joins do not currently work, so don't try it if you have a join
// TODO: Change this to Load1 to be more descriptive and avoid confusion with other Getters
func (b *UnsupportedTypesBuilder) Get(ctx context.Context) *UnsupportedTypes {
	results := b.Limit(1, 0).Load(ctx)
	if results != nil && len(results) > 0 {
		obj := results[0]
		return obj
	} else {
		return nil
	}
}

// Expand expands an array type node so that it will produce individual rows instead of an array of items
func (b *UnsupportedTypesBuilder) Expand(n query.NodeI) *UnsupportedTypesBuilder {
	b.base.Expand(n)
	return b
}

// Join adds a node to the node tree so that its fields will appear in the query. Optionally add conditions to filter
// what gets included. The conditions will be AND'd with the basic condition matching the primary keys of the join.
func (b *UnsupportedTypesBuilder) Join(n query.NodeI, conditions ...query.NodeI) *UnsupportedTypesBuilder {
	var condition query.NodeI
	if len(conditions) > 1 {
		condition = And(conditions)
	} else if len(conditions) == 1 {
		condition = conditions[0]
	}
	b.base.Join(n, condition)
	if condition != nil {
		b.hasConditionalJoins = true
	}
	return b
}

// Where adds a condition to filter what gets selected.
func (b *UnsupportedTypesBuilder) Where(c query.NodeI) *UnsupportedTypesBuilder {
	b.base.Condition(c)
	return b
}

// OrderBy specifies how the resulting data should be sorted.
func (b *UnsupportedTypesBuilder) OrderBy(nodes ...query.NodeI) *UnsupportedTypesBuilder {
	b.base.OrderBy(nodes...)
	return b
}

// Limit will return a subset of the data, limited to the offset and number of rows specified
func (b *UnsupportedTypesBuilder) Limit(maxRowCount int, offset int) *UnsupportedTypesBuilder {
	b.base.Limit(maxRowCount, offset)
	return b
}

// Select optimizes the query to only return the specified fields. Once you put a Select in your query, you must
// specify all the fields that you will eventually read out. Be careful when selecting fields in joined tables, as joined
// tables will also contain pointers back to the parent table, and so the parent node should have the same field selected
// as the child node if you are querying those fields.
func (b *UnsupportedTypesBuilder) Select(nodes ...query.NodeI) *UnsupportedTypesBuilder {
	b.base.Select(nodes...)
	return b
}

// Alias lets you add a node with a custom name. After the query, you can read out the data using GetAlias() on a
// returned object. Alias is useful for adding calculations or subqueries to the query.
func (b *UnsupportedTypesBuilder) Alias(name string, n query.NodeI) *UnsupportedTypesBuilder {
	b.base.Alias(name, n)
	return b
}

// Distinct removes duplicates from the results of the query. Adding a Select() may help you get to the data you want, although
// using Distinct with joined tables is often not effective, since we force joined tables to include primary keys in the query, and this
// often ruins the effect of Distinct.
func (b *UnsupportedTypesBuilder) Distinct() *UnsupportedTypesBuilder {
	b.base.Distinct()
	return b
}

// GroupBy controls how results are grouped when using aggregate functions in an Alias() call.
func (b *UnsupportedTypesBuilder) GroupBy(nodes ...query.NodeI) *UnsupportedTypesBuilder {
	b.base.GroupBy(nodes...)
	return b
}

// Having does additional filtering on the results of the query.
func (b *UnsupportedTypesBuilder) Having(node query.NodeI) *UnsupportedTypesBuilder {
	b.base.Having(node)
	return b
}

// Count terminates a query and returns just the number of items selected.
func (b *UnsupportedTypesBuilder) Count(ctx context.Context, distinct bool, nodes ...query.NodeI) uint {
	return b.base.Count(ctx, distinct, nodes...)
}

// Delete uses the query builder to delete a group of records that match the criteria
func (b *UnsupportedTypesBuilder) Delete(ctx context.Context) {
	b.base.Delete(ctx)
}

// Subquery uses the query builder to define a subquery within a larger query. You MUST include what
// you are selecting by adding Alias or Select functions on the subquery builder. Generally you would use
// this as a node to an Alias function on the surrounding query builder.
func (b *UnsupportedTypesBuilder) Subquery() *query.SubqueryNode {
	return b.base.Subquery()
}

// joinOrSelect us a private helper function for the Load* functions
func (b *UnsupportedTypesBuilder) joinOrSelect(nodes ...query.NodeI) *UnsupportedTypesBuilder {
	for _, n := range nodes {
		switch n.(type) {
		case query.TableNodeI:
			b.base.Join(n, nil)
		case *query.ColumnNode:
			b.Select(n)
		}
	}
	return b
}

func CountUnsupportedTypesByTypeSet(ctx context.Context, typeSet string) uint {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypeSet(), typeSet)).Count(ctx, false)
}

func CountUnsupportedTypesByTypeEnum(ctx context.Context, typeEnum string) uint {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypeEnum(), typeEnum)).Count(ctx, false)
}

func CountUnsupportedTypesByTypeDecimal(ctx context.Context, typeDecimal string) uint {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypeDecimal(), typeDecimal)).Count(ctx, false)
}

func CountUnsupportedTypesByTypeDouble(ctx context.Context, typeDouble float64) uint {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypeDouble(), typeDouble)).Count(ctx, false)
}

func CountUnsupportedTypesByTypeGeo(ctx context.Context, typeGeo string) uint {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypeGeo(), typeGeo)).Count(ctx, false)
}

func CountUnsupportedTypesByTypeTinyBlob(ctx context.Context, typeTinyBlob []byte) uint {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypeTinyBlob(), typeTinyBlob)).Count(ctx, false)
}

func CountUnsupportedTypesByTypeMediumBlob(ctx context.Context, typeMediumBlob []byte) uint {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypeMediumBlob(), typeMediumBlob)).Count(ctx, false)
}

func CountUnsupportedTypesByTypeVarbinary(ctx context.Context, typeVarbinary string) uint {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypeVarbinary(), typeVarbinary)).Count(ctx, false)
}

func CountUnsupportedTypesByTypeLongtext(ctx context.Context, typeLongtext string) uint {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypeLongtext(), typeLongtext)).Count(ctx, false)
}

func CountUnsupportedTypesByTypeBinary(ctx context.Context, typeBinary string) uint {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypeBinary(), typeBinary)).Count(ctx, false)
}

func CountUnsupportedTypesByTypeSmall(ctx context.Context, typeSmall int) uint {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypeSmall(), typeSmall)).Count(ctx, false)
}

func CountUnsupportedTypesByTypeMedium(ctx context.Context, typeMedium int) uint {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypeMedium(), typeMedium)).Count(ctx, false)
}

func CountUnsupportedTypesByTypeBig(ctx context.Context, typeBig int64) uint {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypeBig(), typeBig)).Count(ctx, false)
}

func CountUnsupportedTypesByTypePolygon(ctx context.Context, typePolygon string) uint {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypePolygon(), typePolygon)).Count(ctx, false)
}

func CountUnsupportedTypesByTypeSerial(ctx context.Context, typeSerial string) uint {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypeSerial(), typeSerial)).Count(ctx, false)
}

func CountUnsupportedTypesByTypeUnsigned(ctx context.Context, typeUnsigned uint) uint {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypeUnsigned(), typeUnsigned)).Count(ctx, false)
}

func CountUnsupportedTypesByTypeMultfk1(ctx context.Context, typeMultfk1 string) uint {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypeMultfk1(), typeMultfk1)).Count(ctx, false)
}

func CountUnsupportedTypesByTypeMultifk2(ctx context.Context, typeMultifk2 string) uint {
	return queryUnsupportedTypes(ctx).Where(Equal(node.UnsupportedTypes().TypeMultifk2(), typeMultifk2)).Count(ctx, false)
}

// load is the private loader that transforms data coming from the database into a tree structure reflecting the relationships
// between the object chain requested by the user in the query.
// If linkParent is true we will have child relationships use a pointer back to the parent object. If false, it will create a separate object.
// Care must be taken in the query, as Select clauses might not be honored if the child object has fields selected which the parent object does not have.
// Also, if any joins are conditional, that might affect which child objects are included, so in this situation, linkParent should be false
func (o *unsupportedTypesBase) load(m map[string]interface{}, linkParent bool, objThis *UnsupportedTypes, objParent interface{}, parentKey string) {
	if v, ok := m["type_set"]; ok && v != nil {
		if o.typeSet, ok = v.(string); ok {
			o.typeSetIsValid = true
			o.typeSetIsDirty = false
		} else {
			panic("Wrong type found for type_set.")
		}
	} else {
		o.typeSetIsValid = false
		o.typeSet = ""
	}

	if v, ok := m["type_enum"]; ok && v != nil {
		if o.typeEnum, ok = v.(string); ok {
			o.typeEnumIsValid = true
			o.typeEnumIsDirty = false
		} else {
			panic("Wrong type found for type_enum.")
		}
	} else {
		o.typeEnumIsValid = false
		o.typeEnum = ""
	}

	if v, ok := m["type_decimal"]; ok && v != nil {
		if o.typeDecimal, ok = v.(string); ok {
			o.typeDecimalIsValid = true
			o.typeDecimalIsDirty = false
		} else {
			panic("Wrong type found for type_decimal.")
		}
	} else {
		o.typeDecimalIsValid = false
		o.typeDecimal = ""
	}

	if v, ok := m["type_double"]; ok && v != nil {
		if o.typeDouble, ok = v.(float64); ok {
			o.typeDoubleIsValid = true
			o.typeDoubleIsDirty = false
		} else {
			panic("Wrong type found for type_double.")
		}
	} else {
		o.typeDoubleIsValid = false
		o.typeDouble = 0.0
	}

	if v, ok := m["type_geo"]; ok && v != nil {
		if o.typeGeo, ok = v.(string); ok {
			o.typeGeoIsValid = true
			o.typeGeoIsDirty = false
		} else {
			panic("Wrong type found for type_geo.")
		}
	} else {
		o.typeGeoIsValid = false
		o.typeGeo = ""
	}

	if v, ok := m["type_tiny_blob"]; ok && v != nil {
		if o.typeTinyBlob, ok = v.([]byte); ok {
			o.typeTinyBlobIsValid = true
			o.typeTinyBlobIsDirty = false
		} else {
			panic("Wrong type found for type_tiny_blob.")
		}
	} else {
		o.typeTinyBlobIsValid = false
		o.typeTinyBlob = nil
	}

	if v, ok := m["type_medium_blob"]; ok && v != nil {
		if o.typeMediumBlob, ok = v.([]byte); ok {
			o.typeMediumBlobIsValid = true
			o.typeMediumBlobIsDirty = false
		} else {
			panic("Wrong type found for type_medium_blob.")
		}
	} else {
		o.typeMediumBlobIsValid = false
		o.typeMediumBlob = nil
	}

	if v, ok := m["type_varbinary"]; ok && v != nil {
		if o.typeVarbinary, ok = v.(string); ok {
			o.typeVarbinaryIsValid = true
			o.typeVarbinaryIsDirty = false
		} else {
			panic("Wrong type found for type_varbinary.")
		}
	} else {
		o.typeVarbinaryIsValid = false
		o.typeVarbinary = ""
	}

	if v, ok := m["type_longtext"]; ok && v != nil {
		if o.typeLongtext, ok = v.(string); ok {
			o.typeLongtextIsValid = true
			o.typeLongtextIsDirty = false
		} else {
			panic("Wrong type found for type_longtext.")
		}
	} else {
		o.typeLongtextIsValid = false
		o.typeLongtext = ""
	}

	if v, ok := m["type_binary"]; ok && v != nil {
		if o.typeBinary, ok = v.(string); ok {
			o.typeBinaryIsValid = true
			o.typeBinaryIsDirty = false
		} else {
			panic("Wrong type found for type_binary.")
		}
	} else {
		o.typeBinaryIsValid = false
		o.typeBinary = ""
	}

	if v, ok := m["type_small"]; ok && v != nil {
		if o.typeSmall, ok = v.(int); ok {
			o.typeSmallIsValid = true
			o.typeSmallIsDirty = false
		} else {
			panic("Wrong type found for type_small.")
		}
	} else {
		o.typeSmallIsValid = false
		o.typeSmall = 0
	}

	if v, ok := m["type_medium"]; ok && v != nil {
		if o.typeMedium, ok = v.(int); ok {
			o.typeMediumIsValid = true
			o.typeMediumIsDirty = false
		} else {
			panic("Wrong type found for type_medium.")
		}
	} else {
		o.typeMediumIsValid = false
		o.typeMedium = 0
	}

	if v, ok := m["type_big"]; ok && v != nil {
		if o.typeBig, ok = v.(int64); ok {
			o.typeBigIsValid = true
			o.typeBigIsDirty = false
		} else {
			panic("Wrong type found for type_big.")
		}
	} else {
		o.typeBigIsValid = false
		o.typeBig = 0
	}

	if v, ok := m["type_polygon"]; ok && v != nil {
		if o.typePolygon, ok = v.(string); ok {
			o.typePolygonIsValid = true
			o.typePolygonIsDirty = false
		} else {
			panic("Wrong type found for type_polygon.")
		}
	} else {
		o.typePolygonIsValid = false
		o.typePolygon = ""
	}

	if v, ok := m["type_serial"]; ok && v != nil {
		if o.typeSerial, ok = v.(string); ok {
			o.typeSerialIsValid = true
			o.typeSerialIsDirty = false
		} else {
			panic("Wrong type found for type_serial.")
		}
	} else {
		o.typeSerialIsValid = false
		o.typeSerial = ""
	}

	if v, ok := m["type_unsigned"]; ok && v != nil {
		if o.typeUnsigned, ok = v.(uint); ok {
			o.typeUnsignedIsValid = true
			o.typeUnsignedIsDirty = false
		} else {
			panic("Wrong type found for type_unsigned.")
		}
	} else {
		o.typeUnsignedIsValid = false
		o.typeUnsigned = 0
	}

	if v, ok := m["type_multFk1"]; ok && v != nil {
		if o.typeMultfk1, ok = v.(string); ok {
			o.typeMultfk1IsValid = true
			o.typeMultfk1IsDirty = false
		} else {
			panic("Wrong type found for type_multFk1.")
		}
	} else {
		o.typeMultfk1IsValid = false
		o.typeMultfk1 = ""
	}

	if v, ok := m["type_multiFk2"]; ok && v != nil {
		if o.typeMultifk2, ok = v.(string); ok {
			o.typeMultifk2IsValid = true
			o.typeMultifk2IsDirty = false
		} else {
			panic("Wrong type found for type_multiFk2.")
		}
	} else {
		o.typeMultifk2IsValid = false
		o.typeMultifk2 = ""
	}

	if v, ok := m["aliases_"]; ok {
		o._aliases = map[string]interface{}(v.(db.ValueMap))
	}
	o._restored = true
}

// Save will update or insert the object, depending on the state of the object.
// If it has any auto-generated ids, those will be updated.
func (o *unsupportedTypesBase) Save(ctx context.Context) {
	if o._restored {
		o.Update(ctx)
	} else {
		o.Insert(ctx)
	}
}

// Update will update the values in the database, saving any changed values.
func (o *unsupportedTypesBase) Update(ctx context.Context) {
	if !o._restored {
		panic("Cannot update a record that was not originally read from the database.")
	}
	m := o.getModifiedFields()
	if len(m) == 0 {
		return
	}
	d := db.GetDatabase("goradd")
	d.Update(ctx, "unsupported_types", m, "type_serial", fmt.Sprint(o.typeSerial))
	o.resetDirtyStatus()
}

// Insert forces the object to be inserted into the database. If the object was loaded from the database originally,
// this will create a duplicate in the database.
func (o *unsupportedTypesBase) Insert(ctx context.Context) {
	m := o.getModifiedFields()
	if len(m) == 0 {
		return
	}
	d := db.GetDatabase("goradd")
	id := d.Insert(ctx, "unsupported_types", m)
	o.typeSerial = id
	o.resetDirtyStatus()
	o._restored = true
}

func (o *unsupportedTypesBase) getModifiedFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
	if o.typeSetIsDirty {
		fields["type_set"] = o.typeSet
	}

	if o.typeEnumIsDirty {
		fields["type_enum"] = o.typeEnum
	}

	if o.typeDecimalIsDirty {
		fields["type_decimal"] = o.typeDecimal
	}

	if o.typeDoubleIsDirty {
		fields["type_double"] = o.typeDouble
	}

	if o.typeGeoIsDirty {
		fields["type_geo"] = o.typeGeo
	}

	if o.typeTinyBlobIsDirty {
		fields["type_tiny_blob"] = o.typeTinyBlob
	}

	if o.typeMediumBlobIsDirty {
		fields["type_medium_blob"] = o.typeMediumBlob
	}

	if o.typeVarbinaryIsDirty {
		fields["type_varbinary"] = o.typeVarbinary
	}

	if o.typeLongtextIsDirty {
		fields["type_longtext"] = o.typeLongtext
	}

	if o.typeBinaryIsDirty {
		fields["type_binary"] = o.typeBinary
	}

	if o.typeSmallIsDirty {
		fields["type_small"] = o.typeSmall
	}

	if o.typeMediumIsDirty {
		fields["type_medium"] = o.typeMedium
	}

	if o.typeBigIsDirty {
		fields["type_big"] = o.typeBig
	}

	if o.typePolygonIsDirty {
		fields["type_polygon"] = o.typePolygon
	}

	if o.typeSerialIsDirty {
		fields["type_serial"] = o.typeSerial
	}

	if o.typeUnsignedIsDirty {
		fields["type_unsigned"] = o.typeUnsigned
	}

	if o.typeMultfk1IsDirty {
		fields["type_multFk1"] = o.typeMultfk1
	}

	if o.typeMultifk2IsDirty {
		fields["type_multiFk2"] = o.typeMultifk2
	}

	return
}

// Delete deletes the associated record from the database.
func (o *unsupportedTypesBase) Delete(ctx context.Context) {
	if !o._restored {
		panic("Cannot delete a record that has no primary key value.")
	}
	d := db.GetDatabase("goradd")
	d.Delete(ctx, "unsupported_types", "type_serial", o.typeSerial)
}

// deleteUnsupportedTypes deletes the associated record from the database.
func deleteUnsupportedTypes(ctx context.Context, pk string) {
	d := db.GetDatabase("goradd")
	d.Delete(ctx, "unsupported_types", "type_serial", pk)
}

func (o *unsupportedTypesBase) resetDirtyStatus() {
	o.typeSetIsDirty = false
	o.typeEnumIsDirty = false
	o.typeDecimalIsDirty = false
	o.typeDoubleIsDirty = false
	o.typeGeoIsDirty = false
	o.typeTinyBlobIsDirty = false
	o.typeMediumBlobIsDirty = false
	o.typeVarbinaryIsDirty = false
	o.typeLongtextIsDirty = false
	o.typeBinaryIsDirty = false
	o.typeSmallIsDirty = false
	o.typeMediumIsDirty = false
	o.typeBigIsDirty = false
	o.typePolygonIsDirty = false
	o.typeSerialIsDirty = false
	o.typeUnsignedIsDirty = false
	o.typeMultfk1IsDirty = false
	o.typeMultifk2IsDirty = false
}

func (o *unsupportedTypesBase) IsDirty() bool {
	return o.typeSetIsDirty ||
		o.typeEnumIsDirty ||
		o.typeDecimalIsDirty ||
		o.typeDoubleIsDirty ||
		o.typeGeoIsDirty ||
		o.typeTinyBlobIsDirty ||
		o.typeMediumBlobIsDirty ||
		o.typeVarbinaryIsDirty ||
		o.typeLongtextIsDirty ||
		o.typeBinaryIsDirty ||
		o.typeSmallIsDirty ||
		o.typeMediumIsDirty ||
		o.typeBigIsDirty ||
		o.typePolygonIsDirty ||
		o.typeSerialIsDirty ||
		o.typeUnsignedIsDirty ||
		o.typeMultfk1IsDirty ||
		o.typeMultifk2IsDirty
}

// Get returns the value of a field in the object based on the field's name.
// It will also get related objects if they are loaded.
// Invalid fields and objects are returned as nil
func (o *unsupportedTypesBase) Get(key string) interface{} {

	switch key {
	case "TypeSet":
		if !o.typeSetIsValid {
			return nil
		}
		return o.typeSet

	case "TypeEnum":
		if !o.typeEnumIsValid {
			return nil
		}
		return o.typeEnum

	case "TypeDecimal":
		if !o.typeDecimalIsValid {
			return nil
		}
		return o.typeDecimal

	case "TypeDouble":
		if !o.typeDoubleIsValid {
			return nil
		}
		return o.typeDouble

	case "TypeGeo":
		if !o.typeGeoIsValid {
			return nil
		}
		return o.typeGeo

	case "TypeTinyBlob":
		if !o.typeTinyBlobIsValid {
			return nil
		}
		return o.typeTinyBlob

	case "TypeMediumBlob":
		if !o.typeMediumBlobIsValid {
			return nil
		}
		return o.typeMediumBlob

	case "TypeVarbinary":
		if !o.typeVarbinaryIsValid {
			return nil
		}
		return o.typeVarbinary

	case "TypeLongtext":
		if !o.typeLongtextIsValid {
			return nil
		}
		return o.typeLongtext

	case "TypeBinary":
		if !o.typeBinaryIsValid {
			return nil
		}
		return o.typeBinary

	case "TypeSmall":
		if !o.typeSmallIsValid {
			return nil
		}
		return o.typeSmall

	case "TypeMedium":
		if !o.typeMediumIsValid {
			return nil
		}
		return o.typeMedium

	case "TypeBig":
		if !o.typeBigIsValid {
			return nil
		}
		return o.typeBig

	case "TypePolygon":
		if !o.typePolygonIsValid {
			return nil
		}
		return o.typePolygon

	case "TypeSerial":
		if !o.typeSerialIsValid {
			return nil
		}
		return o.typeSerial

	case "TypeUnsigned":
		if !o.typeUnsignedIsValid {
			return nil
		}
		return o.typeUnsigned

	case "TypeMultfk1":
		if !o.typeMultfk1IsValid {
			return nil
		}
		return o.typeMultfk1

	case "TypeMultifk2":
		if !o.typeMultifk2IsValid {
			return nil
		}
		return o.typeMultifk2

	}
	return nil
}

// MarshalBinary serializes the object into a buffer that is deserializable using UnmarshalBinary.
// It should be used for transmitting database object over the wire, or for temporary storage. It does not send
// a version number, so if the data format changes, its up to you to invalidate the old stored objects.
// The framework uses this to serialize the object when it is stored in a control.
func (o *unsupportedTypesBase) MarshalBinary() (data []byte, err error) {
	buf := new(bytes.Buffer)
	encoder := gob.NewEncoder(buf)

	if err = encoder.Encode(o.typeSet); err != nil {
		return
	}
	if err = encoder.Encode(o.typeSetIsValid); err != nil {
		return
	}
	if err = encoder.Encode(o.typeSetIsDirty); err != nil {
		return
	}

	if err = encoder.Encode(o.typeEnum); err != nil {
		return
	}
	if err = encoder.Encode(o.typeEnumIsValid); err != nil {
		return
	}
	if err = encoder.Encode(o.typeEnumIsDirty); err != nil {
		return
	}

	if err = encoder.Encode(o.typeDecimal); err != nil {
		return
	}
	if err = encoder.Encode(o.typeDecimalIsValid); err != nil {
		return
	}
	if err = encoder.Encode(o.typeDecimalIsDirty); err != nil {
		return
	}

	if err = encoder.Encode(o.typeDouble); err != nil {
		return
	}
	if err = encoder.Encode(o.typeDoubleIsValid); err != nil {
		return
	}
	if err = encoder.Encode(o.typeDoubleIsDirty); err != nil {
		return
	}

	if err = encoder.Encode(o.typeGeo); err != nil {
		return
	}
	if err = encoder.Encode(o.typeGeoIsValid); err != nil {
		return
	}
	if err = encoder.Encode(o.typeGeoIsDirty); err != nil {
		return
	}

	if err = encoder.Encode(o.typeTinyBlob); err != nil {
		return
	}
	if err = encoder.Encode(o.typeTinyBlobIsValid); err != nil {
		return
	}
	if err = encoder.Encode(o.typeTinyBlobIsDirty); err != nil {
		return
	}

	if err = encoder.Encode(o.typeMediumBlob); err != nil {
		return
	}
	if err = encoder.Encode(o.typeMediumBlobIsValid); err != nil {
		return
	}
	if err = encoder.Encode(o.typeMediumBlobIsDirty); err != nil {
		return
	}

	if err = encoder.Encode(o.typeVarbinary); err != nil {
		return
	}
	if err = encoder.Encode(o.typeVarbinaryIsValid); err != nil {
		return
	}
	if err = encoder.Encode(o.typeVarbinaryIsDirty); err != nil {
		return
	}

	if err = encoder.Encode(o.typeLongtext); err != nil {
		return
	}
	if err = encoder.Encode(o.typeLongtextIsValid); err != nil {
		return
	}
	if err = encoder.Encode(o.typeLongtextIsDirty); err != nil {
		return
	}

	if err = encoder.Encode(o.typeBinary); err != nil {
		return
	}
	if err = encoder.Encode(o.typeBinaryIsValid); err != nil {
		return
	}
	if err = encoder.Encode(o.typeBinaryIsDirty); err != nil {
		return
	}

	if err = encoder.Encode(o.typeSmall); err != nil {
		return
	}
	if err = encoder.Encode(o.typeSmallIsValid); err != nil {
		return
	}
	if err = encoder.Encode(o.typeSmallIsDirty); err != nil {
		return
	}

	if err = encoder.Encode(o.typeMedium); err != nil {
		return
	}
	if err = encoder.Encode(o.typeMediumIsValid); err != nil {
		return
	}
	if err = encoder.Encode(o.typeMediumIsDirty); err != nil {
		return
	}

	if err = encoder.Encode(o.typeBig); err != nil {
		return
	}
	if err = encoder.Encode(o.typeBigIsValid); err != nil {
		return
	}
	if err = encoder.Encode(o.typeBigIsDirty); err != nil {
		return
	}

	if err = encoder.Encode(o.typePolygon); err != nil {
		return
	}
	if err = encoder.Encode(o.typePolygonIsValid); err != nil {
		return
	}
	if err = encoder.Encode(o.typePolygonIsDirty); err != nil {
		return
	}

	if err = encoder.Encode(o.typeSerial); err != nil {
		return
	}
	if err = encoder.Encode(o.typeSerialIsValid); err != nil {
		return
	}
	if err = encoder.Encode(o.typeSerialIsDirty); err != nil {
		return
	}

	if err = encoder.Encode(o.typeUnsigned); err != nil {
		return
	}
	if err = encoder.Encode(o.typeUnsignedIsValid); err != nil {
		return
	}
	if err = encoder.Encode(o.typeUnsignedIsDirty); err != nil {
		return
	}

	if err = encoder.Encode(o.typeMultfk1); err != nil {
		return
	}
	if err = encoder.Encode(o.typeMultfk1IsValid); err != nil {
		return
	}
	if err = encoder.Encode(o.typeMultfk1IsDirty); err != nil {
		return
	}

	if err = encoder.Encode(o.typeMultifk2); err != nil {
		return
	}
	if err = encoder.Encode(o.typeMultifk2IsValid); err != nil {
		return
	}
	if err = encoder.Encode(o.typeMultifk2IsDirty); err != nil {
		return
	}

	if o._aliases == nil {
		if err = encoder.Encode(false); err != nil {
			return
		}
	} else {
		if err = encoder.Encode(true); err != nil {
			return
		}
		if err = encoder.Encode(o._aliases); err != nil {
			return
		}
	}

	if err = encoder.Encode(o._restored); err != nil {
		return
	}

	return
}

func (o *unsupportedTypesBase) UnmarshalBinary(data []byte) (err error) {

	buf := bytes.NewBuffer(data)
	dec := gob.NewDecoder(buf)

	if err = dec.Decode(&o.typeSet); err != nil {
		return
	}
	if err = dec.Decode(&o.typeSetIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.typeSetIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.typeEnum); err != nil {
		return
	}
	if err = dec.Decode(&o.typeEnumIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.typeEnumIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.typeDecimal); err != nil {
		return
	}
	if err = dec.Decode(&o.typeDecimalIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.typeDecimalIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.typeDouble); err != nil {
		return
	}
	if err = dec.Decode(&o.typeDoubleIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.typeDoubleIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.typeGeo); err != nil {
		return
	}
	if err = dec.Decode(&o.typeGeoIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.typeGeoIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.typeTinyBlob); err != nil {
		return
	}
	if err = dec.Decode(&o.typeTinyBlobIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.typeTinyBlobIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.typeMediumBlob); err != nil {
		return
	}
	if err = dec.Decode(&o.typeMediumBlobIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.typeMediumBlobIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.typeVarbinary); err != nil {
		return
	}
	if err = dec.Decode(&o.typeVarbinaryIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.typeVarbinaryIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.typeLongtext); err != nil {
		return
	}
	if err = dec.Decode(&o.typeLongtextIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.typeLongtextIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.typeBinary); err != nil {
		return
	}
	if err = dec.Decode(&o.typeBinaryIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.typeBinaryIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.typeSmall); err != nil {
		return
	}
	if err = dec.Decode(&o.typeSmallIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.typeSmallIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.typeMedium); err != nil {
		return
	}
	if err = dec.Decode(&o.typeMediumIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.typeMediumIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.typeBig); err != nil {
		return
	}
	if err = dec.Decode(&o.typeBigIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.typeBigIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.typePolygon); err != nil {
		return
	}
	if err = dec.Decode(&o.typePolygonIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.typePolygonIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.typeSerial); err != nil {
		return
	}
	if err = dec.Decode(&o.typeSerialIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.typeSerialIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.typeUnsigned); err != nil {
		return
	}
	if err = dec.Decode(&o.typeUnsignedIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.typeUnsignedIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.typeMultfk1); err != nil {
		return
	}
	if err = dec.Decode(&o.typeMultfk1IsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.typeMultfk1IsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.typeMultifk2); err != nil {
		return
	}
	if err = dec.Decode(&o.typeMultifk2IsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.typeMultifk2IsDirty); err != nil {
		return
	}

	var hasAliases bool
	if err = dec.Decode(&hasAliases); err != nil {
		return
	}
	if hasAliases {
		if err = dec.Decode(&o._aliases); err != nil {
			return
		}
	}

	if err = dec.Decode(&o._restored); err != nil {
		return
	}

	return err
}

// MarshalJSON serializes the object into a JSON object.
// Only valid data will be serialized, meaning, you can control what gets serialized by using Select to
// select only the fields you want when you query for the object.
func (o *unsupportedTypesBase) MarshalJSON() (data []byte, err error) {
	v := make(map[string]interface{})

	if o.typeSetIsValid {
		v["typeSet"] = o.typeSet
	}

	if o.typeEnumIsValid {
		v["typeEnum"] = o.typeEnum
	}

	if o.typeDecimalIsValid {
		v["typeDecimal"] = o.typeDecimal
	}

	if o.typeDoubleIsValid {
		v["typeDouble"] = o.typeDouble
	}

	if o.typeGeoIsValid {
		v["typeGeo"] = o.typeGeo
	}

	if o.typeTinyBlobIsValid {
		v["typeTinyBlob"] = o.typeTinyBlob
	}

	if o.typeMediumBlobIsValid {
		v["typeMediumBlob"] = o.typeMediumBlob
	}

	if o.typeVarbinaryIsValid {
		v["typeVarbinary"] = o.typeVarbinary
	}

	if o.typeLongtextIsValid {
		v["typeLongtext"] = o.typeLongtext
	}

	if o.typeBinaryIsValid {
		v["typeBinary"] = o.typeBinary
	}

	if o.typeSmallIsValid {
		v["typeSmall"] = o.typeSmall
	}

	if o.typeMediumIsValid {
		v["typeMedium"] = o.typeMedium
	}

	if o.typeBigIsValid {
		v["typeBig"] = o.typeBig
	}

	if o.typePolygonIsValid {
		v["typePolygon"] = o.typePolygon
	}

	if o.typeSerialIsValid {
		v["typeSerial"] = o.typeSerial
	}

	if o.typeUnsignedIsValid {
		v["typeUnsigned"] = o.typeUnsigned
	}

	if o.typeMultfk1IsValid {
		v["typeMultfk1"] = o.typeMultfk1
	}

	if o.typeMultifk2IsValid {
		v["typeMultifk2"] = o.typeMultifk2
	}

	return json.Marshal(v)
}
