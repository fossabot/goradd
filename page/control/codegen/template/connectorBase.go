//** This file was code generated by got. ***

package template

import (
	"bytes"
	"fmt"
	"goradd/config"
	"strconv"
	"strings"

	"github.com/spekary/goradd/codegen/connector"
	"github.com/spekary/goradd/codegen/generator"
	"github.com/spekary/goradd/orm/db"
	"github.com/spekary/goradd/util"
	"github.com/spekary/goradd/util/types"
)

func init() {
	t := ConnectorBaseTemplate{
		generator.Template{
			Overwrite: true,
			TargetDir: config.LocalDir + "/gen",
		},
	}
	generator.AddTableTemplate(&t)
}

type ConnectorBaseTemplate struct {
	generator.Template
}

func (n *ConnectorBaseTemplate) FileName(key string, t *db.TableDescription) string {
	return n.TargetDir + "/" + key + "/connector/" + t.GoName + "Base.go"
}

func (n *ConnectorBaseTemplate) GenerateTable(codegen generator.Codegen, dd *db.DatabaseDescription, t *db.TableDescription, buf *bytes.Buffer) {
	//connector.tmpl

	// The master template for the connector classes

	// As a preliminary step, we need to vet all the controls associated with columns to manage their namespaces.
	var importToNamespace = types.NewOrderedStringMap()
	var namespaceToImport = types.NewOrderedStringMap()

	type columnDescription struct {
		namespace   string
		typ         string
		newFunc     string
		controlName string
		desc        *db.ColumnDescription
		generator   connector.Generator
	}

	var columnDescriptions = make(map[string]columnDescription)

	for _, col := range t.Columns {
		typ, newFunc, importName := codegen.ControlType(col)

		var namespace string
		if typ != "" {
			if !importToNamespace.Has(importName) {
				items := strings.Split(importName, `/`)
				lastName := items[len(items)-1]
				var suffix = ""
				var count = 1
				for namespaceToImport.Has(lastName + suffix) {
					count++
					suffix = strconv.Itoa(count)
				}
				namespace = lastName + suffix
				importToNamespace.Set(importName, namespace)
				namespaceToImport.Set(namespace, importName)
			} else {
				namespace = importToNamespace.Get(importName)
			}
			ci := columnDescription{
				namespace,
				typ,
				newFunc,
				col.GoName + typ,
				col,
				connector.GetGenerator(importName, typ),
			}
			columnDescriptions[col.GoName] = ci
		}
	}

	var privateName = util.LcFirst(t.GoName)

	buf.WriteString(`package connector

// This file is code generated. Do not edit.

`)

	// import.tmpl

	buf.WriteString(`import (
    "github.com/spekary/goradd/page"
	"goradd/gen/`)

	buf.WriteString(fmt.Sprintf("%v", t.DbKey))

	buf.WriteString(`/model"
    `)
	importToNamespace.Range(func(key string, val string) bool {
		buf.WriteString(`    `)

		buf.WriteString(fmt.Sprintf("%v", val))

		buf.WriteString(` "`)

		buf.WriteString(fmt.Sprintf("%v", key))

		buf.WriteString(`"
    `)
		return true
	})

	buf.WriteString(`
)
`)

	// struct.tmpl

	buf.WriteString(`// `)

	buf.WriteString(fmt.Sprintf("%v", privateName))

	buf.WriteString(`Base is a base structure to be embedded in a "subclass" and provides the code generated
// controls and CRUD operations.

type `)

	buf.WriteString(privateName)

	buf.WriteString(`Base struct {
    ParentControl page.ControlI
    EditMode bool
    `)

	buf.WriteString(t.GoName)

	buf.WriteString(` *model.`)

	buf.WriteString(t.GoName)

	buf.WriteString(`
`)
	for _, col := range t.Columns {
		desc, ok := columnDescriptions[col.GoName]
		if ok {
			buf.WriteString(`    `)

			buf.WriteString(desc.controlName)

			buf.WriteString(` *`)

			buf.WriteString(desc.namespace)

			buf.WriteString(`.`)

			buf.WriteString(desc.typ)

			buf.WriteString(`
`)
		}
	}

	buf.WriteString(`}
`)

	buf.WriteString(`func New`)

	buf.WriteString(fmt.Sprintf("%v", t.GoName))

	buf.WriteString(`Connector(parent page.ControlI) *`)

	buf.WriteString(fmt.Sprintf("%v", t.GoName))

	buf.WriteString(` {
    c := new(`)

	buf.WriteString(t.GoName)

	buf.WriteString(`)
    c.ParentControl = parent
    return c
}

`)

	// newControl.tmpl

	buf.WriteString(`
`)
	for _, col := range t.Columns {
		desc, ok := columnDescriptions[col.GoName]
		if ok && desc.generator != nil {
			buf.WriteString(`func (c *`)

			buf.WriteString(fmt.Sprintf("%v", t.GoName))

			buf.WriteString(`) New`)

			buf.WriteString(desc.controlName)

			buf.WriteString(`(id string) *`)

			buf.WriteString(desc.namespace)

			buf.WriteString(`.`)

			buf.WriteString(desc.typ)

			buf.WriteString(` {
    var ctrl *`)

			buf.WriteString(desc.namespace)

			buf.WriteString(`.`)

			buf.WriteString(desc.typ)

			buf.WriteString(`
`)

			buf.WriteString(desc.generator.GenerateCreate(desc.namespace, col))

			buf.WriteString(`
    c.`)

			buf.WriteString(fmt.Sprintf("%v", desc.controlName))

			buf.WriteString(` = ctrl
    return ctrl
}
`)
		}
	}

	buf.WriteString(`
`)

	// load.tmpl

	buf.WriteString(`
// Load will associate the controls with data from the given model.`)

	buf.WriteString(t.GoName)

	buf.WriteString(` object and load the controls with data.
// Generally call this after creating the controls. Otherwise, call Refresh if you Load before creating the controls.
// If you pass a nil object, it will prepare the controls for creating a new record in the database.
func (c *`)

	buf.WriteString(privateName)

	buf.WriteString(`Base) Load(modelObj *model.`)

	buf.WriteString(t.GoName)

	buf.WriteString(`) {
    if modelObj == nil {
        c.`)

	buf.WriteString(t.GoName)

	buf.WriteString(` = model.New`)

	buf.WriteString(t.GoName)

	buf.WriteString(`()
        c.EditMode = false
    } else {
        c.`)

	buf.WriteString(t.GoName)

	buf.WriteString(` = modelObj
        c.EditMode = true
    }
    c.Refresh()
}


// Refresh loads the controls with the cached model.`)

	buf.WriteString(t.GoName)

	buf.WriteString(` object. To load the data fresh from the database,
// call Load instead.
func (c *`)

	buf.WriteString(privateName)

	buf.WriteString(`Base) Refresh() {
`)
	for _, col := range t.Columns {
		buf.WriteString(`
`)
		var sLoad string
		desc, ok := columnDescriptions[col.GoName]
		if ok && desc.generator != nil {
			sLoad = desc.generator.GenerateGet(desc.controlName, t.GoName, col)
		}
		if sLoad != "" {
			buf.WriteString(`    if c.`)

			buf.WriteString(fmt.Sprintf("%v", desc.controlName))

			buf.WriteString(` != nil {
        `)

			buf.WriteString(sLoad)

			buf.WriteString(`
    }
`)
		}
	}

	buf.WriteString(`}
`)

	// save.tmpl

	buf.WriteString(`
// Update will update the related model.`)

	buf.WriteString(t.GoName)

	buf.WriteString(` object with data from the controls.
func (c *`)

	buf.WriteString(privateName)

	buf.WriteString(`Base) Update() {
`)
	for _, col := range t.Columns {
		buf.WriteString(`
`)
		var sUpdate string
		desc, ok := columnDescriptions[col.GoName]
		if ok && desc.generator != nil {
			sUpdate = desc.generator.GeneratePut(desc.controlName, t.GoName, col)
		}
		if sUpdate != "" {
			buf.WriteString(`    if c.`)

			buf.WriteString(fmt.Sprintf("%v", desc.controlName))

			buf.WriteString(` != nil {
        `)

			buf.WriteString(sUpdate)

			buf.WriteString(`
    }
`)
		}
	}

	buf.WriteString(`}

// Save takes the data from the controls and saves it in the database.
func (c *`)

	buf.WriteString(privateName)

	buf.WriteString(`Base) Save(ctx context.Context) {
    c.Update()
    c.`)

	buf.WriteString(t.GoName)

	buf.WriteString(`.Save(ctx)
}

`)

}

func (n *ConnectorBaseTemplate) Overwrite() bool {
	return n.Template.Overwrite
}
