//** This file was code generated by got. ***

package template

import (
	"bytes"
	"fmt"
	"goradd/config"
	"strconv"
	"strings"

	"github.com/spekary/goradd/codegen/connector"
	"github.com/spekary/goradd/codegen/generator"
	"github.com/spekary/goradd/orm/db"
	"github.com/spekary/goradd/util"
	"github.com/spekary/goradd/util/types"
)

func init() {
	t := ConnectorBaseTemplate{
		generator.Template{
			Overwrite: true,
			TargetDir: config.LocalDir + "/gen",
		},
	}
	generator.AddTableTemplate(&t)
}

type ConnectorBaseTemplate struct {
	generator.Template
}

func (n *ConnectorBaseTemplate) FileName(key string, t *db.TableDescription) string {
	return n.TargetDir + "/" + key + "/connector/" + t.GoName + "Base.go"
}

func (n *ConnectorBaseTemplate) GenerateTable(codegen generator.Codegen, dd *db.DatabaseDescription, t *db.TableDescription, buf *bytes.Buffer) {
	//connector.tmpl

	// The master template for the connector classes

	// As a preliminary step, we need to vet all the controls associated with columns to manage their namespaces.
	var importToNamespace = types.NewOrderedStringMap()
	var namespaceToImport = types.NewOrderedStringMap()

	type columnDescription struct {
		namespace   string
		typ         string
		newFunc     string
		controlName string
		desc        *db.ColumnDescription
		generator   connector.Generator
	}

	var columnDescriptions = make(map[string]columnDescription)

	for _, col := range t.Columns {
		typ, newFunc, importName := codegen.ControlType(col)

		var namespace string
		if typ != "" {
			if !importToNamespace.Has(importName) {
				items := strings.Split(importName, `/`)
				lastName := items[len(items)-1]
				var suffix = ""
				var count = 1
				for namespaceToImport.Has(lastName + suffix) {
					count++
					suffix = strconv.Itoa(count)
				}
				namespace = lastName + suffix
				importToNamespace.Set(importName, namespace)
				namespaceToImport.Set(namespace, importName)
			} else {
				namespace = importToNamespace.Get(importName)
			}
			ci := columnDescription{
				namespace,
				typ,
				newFunc,
				col.GoName + typ,
				col,
				connector.GetGenerator(importName, typ),
			}
			columnDescriptions[col.GoName] = ci
		}
	}

	var privateName = util.LcFirst(t.GoName)

	buf.WriteString(`package connector

// This file is code generated. Do not edit.

`)

	// import.tmpl

	buf.WriteString(`import (
	"goradd/gen/`)

	buf.WriteString(fmt.Sprintf("%v", t.DbKey))

	buf.WriteString(`/model"
    `)
	importToNamespace.Range(func(key string, val string) bool {
		buf.WriteString(`    `)

		buf.WriteString(fmt.Sprintf("%v", val))

		buf.WriteString(` "`)

		buf.WriteString(fmt.Sprintf("%v", key))

		buf.WriteString(`"
    `)
		return true
	})

	buf.WriteString(`
)
`)

	// struct.tmpl

	buf.WriteString(`// `)

	buf.WriteString(fmt.Sprintf("%v", privateName))

	buf.WriteString(`Base is a base structure to be embedded in a "subclass" and provides the code generated
// controls and CRUD operations.

type `)

	buf.WriteString(privateName)

	buf.WriteString(`Base struct {
    ParentControl page.ControlI
    `)

	buf.WriteString(t.GoName)

	buf.WriteString(` *model.`)

	buf.WriteString(t.GoName)

	buf.WriteString(`
`)
	for _, col := range t.Columns {
		desc, ok := columnDescriptions[col.GoName]
		if ok {
			buf.WriteString(`    `)

			buf.WriteString(desc.controlName)

			buf.WriteString(` *`)

			buf.WriteString(desc.namespace)

			buf.WriteString(`.`)

			buf.WriteString(desc.typ)

			buf.WriteString(`
`)
		}
	}

	buf.WriteString(`}
`)

	buf.WriteString(`func New`)

	buf.WriteString(fmt.Sprintf("%v", t.GoName))

	buf.WriteString(`Connector(parent page.ControlI) *`)

	buf.WriteString(fmt.Sprintf("%v", t.GoName))

	buf.WriteString(` {
    c := new(`)

	buf.WriteString(t.GoName)

	buf.WriteString(`)
    c.ParentControl = parent
    return c
}

`)

}

func (n *ConnectorBaseTemplate) Overwrite() bool {
	return n.Template.Overwrite
}
